<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Electron+Vue的使用</title>
    <link href="/2021/03/03/Electron+Vue%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/03/03/Electron+Vue%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="关于Electron"><a href="#关于Electron" class="headerlink" title="关于Electron"></a>关于Electron</h1><p>使用Electron可以很方便的创建跨平台桌面端的Web程序，而提到Electron就不得不提到Node.js,因为Electron用Node做后台，只要你需要通过Electron来访问网络或是硬盘，就得依靠Node，而Electron也使用Node来管理依赖项，你只需要使用<code>npm install</code>命令便可很方便的为你的Electron添加不同的依赖库。</p><p>所以创建一个Electron项目的第一步便是安装Node的环境，无论你是macOS还是Windows，比较简单的方式便是使用<a href="https://nodejs.org/">Node官网</a>提供的安装包，你只需要去下载相应版本的安装包即可，建议安装<strong>LTS版本</strong>，下载好后根据安装向导完成安装便完成安装了。</p><p>如果你需要下载特定版本的Node.js，可以在官网下方找到Node的所有历史版本，根据需要下载即可。</p><p><img src="https://blog0508.oss-cn-beijing.aliyuncs.com/image/Electron%2BVue2.png" alt="Electron+Vue2"></p><p><img src="https://blog0508.oss-cn-beijing.aliyuncs.com/image/Electron%2BVue3.png" alt="Electron+Vue3"></p><h1 id="创建第一个Electron程序"><a href="#创建第一个Electron程序" class="headerlink" title="创建第一个Electron程序"></a>创建第一个Electron程序</h1><p>在<a href="https://www.electronjs.org/">Electron官网</a>上我们可以通过其<strong>electron-quick-start</strong>项目来作为基础进行构建，通过：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 克隆示例项目的仓库</span><br>$ git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/electron/electron-quick-<span class="hljs-literal">start</span><br><br><span class="hljs-comment"># 进入这个仓库</span><br>$ cd electron-quick-<span class="hljs-literal">start</span><br><br><span class="hljs-comment"># 安装依赖并运行</span><br>$ npm install &amp;&amp; npm star<br></code></pre></td></tr></table></figure><p>然后我们就可以通过npm start来启动我们的electron项目了！</p><h1 id="上手Vue-搭建Vue环境"><a href="#上手Vue-搭建Vue环境" class="headerlink" title="上手Vue,搭建Vue环境"></a>上手Vue,搭建Vue环境</h1><p>搭建Vue的开发环境我们需要用到Vue的脚手架工具vue-cli，由于vue-cli2.X版本要淘汰了，所以我们需要使用vue-cli3.0及其以上的版本进行项目的创建，2.X的vue-cli你只需要通过<code>npm install -g vue-cli</code>命令即可安装，但3.0及其以上版本的vue-cli你只能通过<code>npm install -g @vue/cli</code>，注意，它的库的名字改为了**@vue/cli**，然后我们就可以开始使用vue-cli创建一个Vue项目了，运行如下命令</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">vue create <span class="hljs-keyword">my</span>-<span class="hljs-keyword">first</span>-demo<br></code></pre></td></tr></table></figure><p>根据需要选择相应配置，完成如图：</p><p><img src="https://blog0508.oss-cn-beijing.aliyuncs.com/image/Electron%2BVue4.png" alt="Electron+Vue4"></p><p><img src="https://blog0508.oss-cn-beijing.aliyuncs.com/image/Electron%2BVue5.png" alt="Electron+Vue5"></p><p>然后进入项目目录，通过</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> my-first-demo<br>npm <span class="hljs-keyword">run</span> serve <span class="hljs-comment">// 如果是yarn的话，就是yarn serve</span><br></code></pre></td></tr></table></figure><p>启动后如图：</p><p><img src="https://blog0508.oss-cn-beijing.aliyuncs.com/image/Electron%2BVue6.png" alt="Electron+Vue6"></p><p>可以通过执行命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> build<br></code></pre></td></tr></table></figure><p>来对项目进行构建生成，完成后项目目录下会生成一个dist文件夹。</p><p>项目文件结构如图：</p><p><img src="https://blog0508.oss-cn-beijing.aliyuncs.com/image/Electron%2BVue7.png" alt="Electron+Vue7"></p><h1 id="引入Electron"><a href="#引入Electron" class="headerlink" title="引入Electron"></a>引入Electron</h1><p>在Vue项目中引入Electron的方式有很多，我们可以直接执行命令<code>npm install electron</code>来安装Electron，然后通过在dist文件夹内创建<strong>主程序的入口文件main.js</strong>和相关<strong>配置文件package.json</strong>的方式来引入electron。</p><p>可以参考：<a href="https://www.cnblogs.com/jiangxifanzhouyudu/p/9517651.html">手把手教Electron+vue的使用</a></p><p>当然也可以通过脚手架工具，例如electron-vue，或者通过Vue插件Vue CLI Plugin Electron Builder 来实现，考虑到electron-vue这个脚手架工具很久没更新了，其中的electron版本还是2.X的，还得手动替换很多东西，不是很方便，但感兴趣的同学可以参考他的<a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/">官方文档</a>，这里我们使用<strong>Vue CLI Plugin Electron Builder</strong>。</p><p>注意，如果你的vue-cli还是2.X版本的话，你需要卸载它，然后安装3.X以上的版本进行创建，否则你是使用不了Vue CLI Plugin Electron Builder的。</p><p>首先，我们先进入之前建立好的Vue项目，然后按以下命令安装并调用vue-cli-plugin-electron-builder的生成器：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> my-<span class="hljs-keyword">first</span>-demo<br>vue <span class="hljs-built_in">add</span> electron-builder <br></code></pre></td></tr></table></figure><p>注意，期间根据你的情况选择相应electron版本，这里我选择的是electron5.0的版本，根据你本地的Node.js版本你可以选择更高版本。</p><p>安装好后可以打开package.js文件可以发现electron已经成功引入</p><p><img src="https://blog0508.oss-cn-beijing.aliyuncs.com/image/Electron%2BVue8.png" alt="Electron+Vue8"></p><p>接下来我们通过运行命令，来让我们的项目跑起来</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> electron:serve<br></code></pre></td></tr></table></figure><p>如图所示，一个简单的Electron程序就成功运行起来了</p><p><img src="https://blog0508.oss-cn-beijing.aliyuncs.com/image/Electron%2BVue9.png" alt="Electron+Vue9"></p><p>打开之前的项目目录，可以看到项目目录下多了一个dis_electron文件夹，其中也有一个package.json文件，指定在src目录下background.js为Electron入口文件，其作用和之前手动添加main.js和package.json的方式一样。</p><p><img src="https://blog0508.oss-cn-beijing.aliyuncs.com/image/Electron%2BVue10.png" alt="Electron+Vue10"></p><p>下面我们通过构建命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> electron:build<br></code></pre></td></tr></table></figure><p>完成后在dist_electron文件夹下就可以看到我们生成的Windows平台的安装程序</p><p><img src="https://blog0508.oss-cn-beijing.aliyuncs.com/image/Electron%2BVue11.png" alt="Electron+Vue11"></p><p>如果需要生成macOS或是Linux平台的安装包，可以阅读electron的<a href="https://www.electronjs.org/docs">官方文档</a>，获取更进一步的详细配置。</p><p>注意，可能在过程中由于网络问题，我们可能会构建失败，所需要的依赖文件可以通过以下几个办法来解决。</p><p>1.设置淘宝镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm set ELECTRON_MIRROR=http:<span class="hljs-regexp">//</span>npm.taobao.org<span class="hljs-regexp">/mirrors/</span>electron/<br></code></pre></td></tr></table></figure><p>设置好后所需要的依赖文件就应该可以下载好了</p><p>2.手动添加</p><p>如果设置淘宝镜像还是不行的话可以在 <a href="https://npm.taobao.org/mirrors/electron">https://npm.taobao.org/mirrors/electron</a> 中找到提示中你所需的对应版本的文件，当然还有几个文件需要我们前往对应网站去下载对应版本的包才行</p><ul><li><a href="https://github.com/electron-userland/electron-builder-binaries/releases/">winCodeSign</a></li><li><a href="https://github.com/electron-userland/electron-builder-binaries/releases/">nsis</a></li><li><a href="https://github.com/electron-userland/electron-builder-binaries/releases/">nsis-resources</a></li></ul><p>下载对应文件后，解压到C:\Users\你的用户名\AppData\Local\electron\Cache中，或是C:\Users\Administrator\AppData\Local\electron-builder\cache下的不同的依赖文件夹里，根据所需版本在里面创建新的文件夹,文件夹名字需要和npm run build里要求下载的文件名一致，例如 <code>nsis-resources-3.3.0</code> 后面的版本要对应上。</p><p>完成上述配置后，再次运行<code>npm run electron:build</code>便不会再报错。</p>]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于JavaScript的闭包</title>
    <link href="/2020/09/05/%E5%85%B3%E4%BA%8EJavascript%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <url>/2020/09/05/%E5%85%B3%E4%BA%8EJavascript%E7%9A%84%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>理解闭包的前提是理解JavaScript的<strong>变量作用域</strong>，变量的作用域分为<strong>全局变量</strong>和<strong>局部变量</strong>， JavaScript具有基于<strong>函数的作用域</strong>，每声明一个函数都会为其自身创建一个自己的<strong>执行环境</strong>，而且在函数内部就可以直接访问全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(a);<br>&#125;<br>func1(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>但是在函数外是无法访问函数内的局部变量的。不过如果不使用<code>var</code>关键字，就会在内部作用域声明一个全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><p>这里就涉及到一个问题，假如我们需要读取函数内部的变量怎么办？于是我们只能在函数的内部再定义一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>    &#125;<br>    <span class="hljs-keyword">return</span> func2;<br>&#125;<br><span class="hljs-keyword">var</span> n = func1();<br>n(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>此时，func1内的所有局部变量对于func2来说都是<strong>可见</strong>的，func1的返回值，也就是func2（），赋值给变量n，然后调用n(),<strong>实际只是通过不同的标识符来引用调用了内部的函数func2()</strong>.</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>说了半天，那么闭包到底是啥，我的理解是：闭包就是函数的局部变量的集合，能够读取其他函数的局部变量，只有定义在函数内部的子函数才可以获取局部变量，<strong>当一个函数定义在另一个函数内，并且试图通过子函数获得局部变量，它就是闭包</strong>。</p><p>闭包使得函数内部作用域和函数外部作用域的连接成为了可能，局部变量可以在函数返回后被访问，而且闭包里变量的值可以始终保持在内存中，我们可以通过一个例子来看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> n=<span class="hljs-number">1</span>;<br>Add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    n += <span class="hljs-number">1</span><br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(n);<br>&#125;<br><span class="hljs-keyword">return</span> func2;<br>&#125;<br><span class="hljs-keyword">var</span> result = func1();<br>result(); <span class="hljs-comment">// 1</span><br>Add();<br>result(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>可以看到局部变量n一直保存在内存中，不会随着函数调用的结束而被垃圾回收，func2是func1的子函数，但作为func1的返回值，却被赋值给了一个全局变量result，这就使得func2始终在内存中，因为func2的存在依赖于func1，所以func1也就跟着保存在了内存中。</p><p>前面提到，如果不使用<code>var</code>关键字，会在内部声明一个全局变量，所以Add就是一个全局变量，但它可以在函数外部对内部的局部变量进行操作，实则它也是一个闭包。</p><p><strong>过渡</strong>的使用闭包，内存消耗会很大，但闭包的用处也很多，在定时器、事件监听器、Ajax 请求、跨窗口通信或者任何其他的异步或者同步任务中，只要使用了回调函数，实际上就是在使用闭包。</p>]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于JavaScript中的继承机制</title>
    <link href="/2020/08/21/%E5%85%B3%E4%BA%8EJavascript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/08/21/%E5%85%B3%E4%BA%8EJavascript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>传统的面向对象语言里，基本都支持继承的两种方式：<strong>接口继承</strong>和<strong>实现继承</strong>。接口继承<strong>继承方法签名</strong>，而实现继承则<strong>继承实际的方法</strong>。至于JavaScript里的继承，由于函数没有签名，只能支持实现继承，而且主要通过<strong>原型链</strong>来实现的。每一个<strong>构造函数</strong>都有一个<strong>原型对象</strong>，原型对象都包含一个<strong>指向构造函数的指针</strong>，而实例又都包含一个<strong>指向原型对象的内部指针</strong>，通过使用原型，将方法添加在”父类“的原型里，然后”子类“的原型就是父类的一个实例化对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">SubClass.prototype = <span class="hljs-keyword">new</span> SuperClass() ;<br></code></pre></td></tr></table></figure><p>如此层层递进，就构成了<strong>实例与原型的链条</strong>，这就是原型链。但原型链也有问题，原先实例的属性会在这个继承的过程中顺理成章的成为其“子类”的原型属性。而且创建的”子类“的实例，无法在不影响所有对象实例的情况下，像”超类“的构造函数传递参数，于是有了构造函数继承。</p><h1 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h1><p>构造函数继承的核心思想就是<code>SuperClass.call(this)</code>,通过<code>call()</code>和<code>apply()</code>方法，<strong>在新创建的对象上执行构造函数，然后改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费的问题</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperClass</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;read&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>,<span class="hljs-string">&quot;yellow&quot;</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubClsss</span>(<span class="hljs-params"></span>)</span>&#123;<br>SuperClass.call(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h1><p>组合式继承，也叫作伪经典继承，结合了前两者的特点，既不会使每个实例化的“子类”互相影响，也避免了内存的浪费。它<strong>使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承</strong>。既可以在原型上定义方法实现实现函数复用，又能保证每个实例都有它自己单独的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperClass</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;read&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>,<span class="hljs-string">&quot;yellow&quot;</span>];<br>&#125;<br><br>SuperClass.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubClass</span>(<span class="hljs-params">name, age</span>)</span>&#123;<br><span class="hljs-comment">//继承属性</span><br>SuperClass.call(<span class="hljs-built_in">this</span>, name);<br>    <span class="hljs-built_in">this</span>.age = age<br>&#125;<br><br><span class="hljs-comment">//继承方法</span><br>SubClass.prototype = <span class="hljs-keyword">new</span> SuperClass<br>SubClass.prototype.constructor = SubClass;<br>SubClass.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><p>寄生式继承的思路是<strong>创建一个仅用于封装继承过程的函数，该函数的内部以某种方式来增强对象，然后返回对象</strong>，就像所有都是它做的一样，很像工厂模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params">original</span>)</span>&#123;<br><span class="hljs-comment">//通过调用函数创建一个新对象</span><br>    <span class="hljs-keyword">var</span> clone = object(original);<br>    clone.sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;;<br><span class="hljs-keyword">return</span> clone;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过使用这种模式来为对象添加函数，会因为不能做到函数复用而降低效率，所以出现了寄生组合式继承。</p><h1 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h1><p>组合式继承的方法固然好，但是会导致一个问题，父类的构造函数会被创建两次（call()的时候一遍，new的时候又一遍），所以为了解决这个问题，又出现了寄生组合继承。集寄生式继承和组合继承的优点于一身，本质上就是<strong>使用寄生式继承来继承“超类”的原型，然后再将结果指定给“子类”的原型。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritObject</span>(<span class="hljs-params">subClass,superClass</span>) </span>&#123;<br>    <span class="hljs-comment">//复制一份父类的原型保存在变量中</span><br><span class="hljs-keyword">var</span> p = inheritObject(superClass.prototype);<br>    <span class="hljs-comment">//修正因为重写子类原型导致子类constructor属性被修改</span><br>p.constructor = subClass;<br>    <span class="hljs-comment">//设置子类的原型</span><br>    subClass.prototype = p;<br>    &#125;<br>    <span class="hljs-comment">//定义父类</span><br><span class="hljs-keyword">var</span> SuperClass = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br><span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.books = [<span class="hljs-string">&#x27;javascript&#x27;</span>,<span class="hljs-string">&#x27;html&#x27;</span>,<span class="hljs-string">&#x27;css&#x27;</span>]<br>    &#125;;<br><span class="hljs-comment">//定义父类原型方法</span><br>SuperClass.prototype.getBooks = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.books)<br>&#125;;<br><span class="hljs-comment">//定义子类</span><br><span class="hljs-keyword">var</span> SubClass = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    SuperClass.call(<span class="hljs-built_in">this</span>,name)<br>&#125;<br>inheritObject(SubClass,SuperClass);<br><br><span class="hljs-keyword">var</span> subclass1 = <span class="hljs-keyword">new</span> SubClass(<span class="hljs-string">&#x27;Java&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中this的原理</title>
    <link href="/2020/08/17/JavaScript%E4%B8%ADthis%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2020/08/17/JavaScript%E4%B8%ADthis%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h1><p>为啥要有这个关键字呢？如果不使用this，我们在写代码时就需要显示的传入上下文对象。会很麻烦，随着代码量的增多，会使代码变得混乱，而this可以隐式“传递”一个对象的引用，利于代码复用，因为它会动态的判断上下文环境，然后引用合适的上下文对象。</p><p>我们可能会在学习时产生片面的误解，一种是我们认为this指向函数自身，另一种是我们认为this指向函数的作用域。因为在一些情况下，它们是对的，但有时却是错误的，举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">this</span>.bar();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br>foo(); <span class="hljs-comment">// ReferenceError: a is not defined</span><br></code></pre></td></tr></table></figure><p>如果按之间的观点，那这段代码应该能正确调用，但实则不能，可见this关键字不是我们之前想的那样。</p><h2 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h2><blockquote><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。 this 就是记录的其中一个属性，会在函数执行的过程中用到。</p></blockquote><p>理解this的前提，我们需要知道什么叫做<strong>调用位置</strong>，调用位置就是函数在代码中被调用的位置，而不是声明的位置，通过调用位置我们才好判断this究竟引用的是什么。</p><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p><strong>this永远指向最后调用它的那个对象</strong>，通过这句话就能很容易判断this的指向，因为调用位置就在当前正在执行的函数的前一个调用中。</p><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>foo(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>我们可以看到，最后调用<code>foo()</code>的地方，它的前面没有明显的调用对象，所以就是全局对象window，相当于<code>window.foo()</code>那么<code>this</code>的指向就是就是<code>window</code>这个全局对象，所以<code>window.a</code>的值就是1。这是默认的绑定情况。</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>我们有时候还要考虑调用位置是否具有上下文对象，可以看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br><span class="hljs-attr">foo</span>: foo<br>&#125;;<br>obj.foo(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>这就简单了，因为this永远指向最后调用它的那个对象，最后调用它的是<code>obj</code>，所以就相当于<code>obj.a</code>，所以值为1，下面是另一种情况，可能我们调用时是在一个属性引用链上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br><span class="hljs-attr">foo</span>: foo<br>&#125;;<br><span class="hljs-keyword">var</span> obj1 = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br><span class="hljs-attr">obj2</span>: obj2<br>&#125;;<br>obj1.obj2.foo(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>不用在意obj1，这里我们要强调“最后调用”，所以最后调用的是obj2，obj1先调用obj2，obj2再调用foo(),所以结果就是<code>obj2.a</code>，所以值为2。</p><p>但假如我们给函数起了别名，可以通过一个例子看一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br><span class="hljs-attr">foo</span>: foo<br>&#125;;<br><span class="hljs-keyword">var</span> bar = obj.foo; <span class="hljs-comment">// 函数别名！</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><br>bar(); <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>虽然我们将 obj 对象的 foo 方法赋值给变量 bar 了，但是没有调用，所以<code>bar()</code>最后还是被全局对象window调用了，this的指向就是window，就相当于<code>window.a</code>，所以值为hello。</p><p>不过我们需要尤为注意回调函数里的this的指向问题，因为回调函数里我们传入的函数，实际上它相当于给里面的形参取了一个别名。当我们分析this的指向时，它实际的指向会被误导，但实质上它还是指向最后调用它的那个对象。</p><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>如果我们想在某个对象上强制调用函数，可以直接指定this指向<br>的对象，什么意思呢，我们先看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>:<span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>foo.call( obj ); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>我们通过call()函数，将obj的作用域传递进了foo中，因为JavaScript存在一个作用域链，相当于我们<code>window.obj.foo()</code>,所以最后调用的是obj对象，所以值为1。我们把foo的this绑定到了obj上。也可以通过<code>apply()</code>和<code>bind()</code>方法。</p><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>) </span>&#123;<br><span class="hljs-built_in">this</span>.a = a;<br>&#125;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> foo(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.log( bar.a ); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>使用<code>new</code>来调用<code>foo()</code>时，我们会构造一个新对象，这个新对象会绑定到foo()调用中的this上，所以<code>bar.a</code>的值就是1，和隐式绑定里的取别名是不一样的，它依然指向最后调用它的那个对象。</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6里，我们可以使用箭头函数始终指向函数定义时的this，不用担心执行时改变，在箭头函数里也没有this绑定了，上面四条绑定原则也不存在了，要根据作用域链来决定它的值，箭头函数会继承外层函数调用的 this 绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">var</span> ogj = &#123;<br>    <span class="hljs-attr">b</span> : <span class="hljs-string">&quot;hi&quot;</span><br>    <span class="hljs-attr">func1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.b);<br>    &#125;,<br>    <span class="hljs-attr">func2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">this</span>.func1()<br>        &#125;,<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;;<br>obj.func2()     <span class="hljs-comment">// hi</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，我们要记住”<strong>this永远指向最后调用它的那个对象</strong>“，具体绑定的方式，如果是由<code>new</code>调用，那它就绑定到了新创建的对象上，如果由<code>call()</code>、<code>apply()</code>、<code>bind()</code>调用，那么就是在绑定的那个对象上，如果包含上下文调用的隐式绑定，要注意上下文对象，如果包含回调函数，要格外小心。如果使用了箭头函数，注意根据作用域链来决定“this”的指向。</p>]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式小记</title>
    <link href="/2020/07/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E8%AE%B0/"/>
    <url>/2020/07/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="关于正则表达式"><a href="#关于正则表达式" class="headerlink" title="关于正则表达式"></a>关于正则表达式</h1><p>正则表达式是为了从大量数据中检索匹配出所需数据的一种强有力的工具，它赋予使用者描述和分析文本的能力，如果没有正则表达式，我们也可以实现同样的功能，只是需要通过循环遍历，通过大量的条件判断才能得到想要的结果。而正则表达式只需要简单的而命令，就能够检索所有文件。</p><h2 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h2><p>“ . “: 使用<code>.</code>字符匹配<strong>任意单个字符、字母、数字或者<code>.</code>字符本身</strong>，不过要在<code>.</code>的前面加上 \ ，对它进行转义，匹配其他元字符也一样。<br>“^”: 使用<code>^</code>会匹配行或者字符串的<strong>起始位置</strong><br>“$”: 使用<code>$</code>会匹配行或者字符串的<strong>末位</strong><br>“\d”: 匹配<strong>数字</strong>，如果是匹配<strong>非数字</strong>字符，只用把d大写就行<code>\D</code><br>“\w”: 匹配<strong>字母数字和下划线</strong>，等价于[a-zA-Z0-9_],如果是匹配<strong>非字母数字或下划线字符</strong>，只用把w大写就行<code>\W</code><br>“\s”: 匹配<strong>空白字符</strong>，如果是匹配<strong>非空白字符</strong>，只用把s大写就行<code>\S</code><br>“\b”: 匹配一个<strong>单词的开始或是结尾</strong>，这个“单词”在正则表达式看来就是一个与<code>\w</code>相匹配的字符和一个与<code>\W</code>相匹配的字符之间的位置，它只匹配一个位置，不匹配任何字符，<code>\B</code>表示不匹配一个单词的边界<br>“ [ ] “: 只匹配括号内定义的<strong>字符集合</strong>，字符集合可以按字符区间来表示区间内所有字符，以下是一些合法的字符区间例子:</p><ul><li>A-Z 匹配A到Z的所有大写字母</li><li>a-z 匹配A到Z的所有小写字母</li><li>A-z 匹配ASCII字符A到ASCALL字符z的所有字符，其中也包含[或是^等类似字符，可能匹配到多余结果。</li></ul><h2 id="POSIX字符类"><a href="#POSIX字符类" class="headerlink" title="POSIX字符类"></a>POSIX字符类</h2><p>POSIX字符类是一种正则表达式的简写形式，可以通过元字符和POSIX字符类的组合来简化正则表达式。<br><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E8%AE%B01.jpg" alt="正则表达式小记1"></p><h2 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h2><p>正则表达式可以进行重复匹配，匹配多个连续出现的字符或者字符集。</p><ul><li><strong>“ * “：匹配零次或多次</strong><br>例如：<code>a*</code>会匹配到所有的字符或字符集为”a”的情况</li><li><strong>“ + “：匹配一次或多次，至少一次</strong><br>例如：<code>a+</code>会匹配到字符或字符集中为”a”的情况，<code>a+</code>与<code>a*</code>不同在于”+”至少是一次而”*” 可以是0次</li><li><strong>“ ? “：匹配零次或一次</strong><br>例如：<code>a?</code>只会匹配一次，也就是结果可能只有单个字符a</li><li><strong>“{n}”：重复n次匹配</strong><br>例如：<code>a&#123;3&#125;</code>结果就是匹配到满足3个a字符的情况 “aaa”</li><li><strong>“{n,m}”：重复n到m次匹配</strong><br>例如：<code>a&#123;2,3&#125;</code> 将a重复匹配2次或者3次 所以匹配到的字符可以是两个”aa”也可以是三个”aaa”</li><li><strong>“{n,}”：重复n次或更多次匹配，至少匹配n次</strong></li></ul><h2 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h2><p>子表达式是为了解决一些特殊匹配情况下使用的，使用一对圆括号把正则表达式括起来，按我的理解，其实它就是解决一个优先级和整体匹配的问题，类似于C语言里的双括号，为了显式增强操作符优先级顺序，避免混乱。</p><p>举个例子：<br><code>&amp;nbsp;&#123;2,4&#125;</code> 这个正则表达式的原意是为了匹配<code>&amp;nbsp</code>两次到四次，但实际{2,4}只作用于它的前一个字符，相当于它只会匹配到<code>&amp;nbsp;;</code> 、 <code>&amp;nbsp;;;</code> 、 <code>&amp;nbsp;;;;</code>。</p><p>所以引入了子表达式，<code>(&amp;nbsp;)&#123;2,4&#125;</code>这样就能按我们预期的结果进行匹配了，它会把<code>&amp;nbsp;</code>看成一个整体进行匹配。</p><p>子表达式也是可以进行嵌套使用的，但我们要尽量避免嵌套次数过多引起的逻辑混乱，阅读困难。</p><h1 id="常见问题的正则表达式"><a href="#常见问题的正则表达式" class="headerlink" title="常见问题的正则表达式"></a>常见问题的正则表达式</h1><p>这里是一些网上搜集的常见的正则表达式匹配的例子，<strong>学习正则表达式最好的方式就是多练习多思考，通过这些简单的例子作为参考来学习，由浅入深，而不是直接复制拿来用，真正掌握了正则表达式才能灵活应对各种情况。它仅仅是一个方法的参考，而非方法本身。</strong></p><h2 id="检验数字"><a href="#检验数字" class="headerlink" title="检验数字"></a>检验数字</h2><ol><li><p><strong>数字</strong>：<code>^[0-9]*$</code></p></li><li><p><strong>n位的数字</strong>：<code>^\d&#123;n&#125;$</code></p></li><li><p><strong>至少n位的数字</strong>：<code>^\d&#123;n,&#125;$</code></p></li><li><p><strong>m - n位的数字</strong>：<code>^\d&#123;m,n&#125;$</code></p></li><li><p><strong>零和非零开头的数字</strong>：<code>^(0|[1-9][0-9]*)$</code></p></li><li><p><strong>非零开头的最多带两位小数的数字</strong>：<code>^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</code></p></li><li><p><strong>带1 - 2位小数的正数或负数</strong>：<code>^(\-)?\d+(\.\d&#123;1,2&#125;)?$</code></p></li><li><p><strong>正数、负数、和小数</strong>：<code>^(\-|\+)?\d+(\.\d+)?$</code></p></li><li><p><strong>有两位小数的正实数</strong>：<code>^[0-9]+(.[0-9]&#123;2&#125;)?$</code></p></li><li><p><strong>有1 - 3位小数的正实数</strong>：<code>^[0-9]+(.[0-9]&#123;1,3&#125;)?$</code></p></li><li><p><strong>非零的正整数</strong>：<code>^[1-9]\d*$</code></p></li><li><p><strong>非零的负整数</strong>： <code>^-[1-9]\d*$</code></p></li><li><p><strong>非负整数</strong>：<code>^\d+$ 或 ^[1-9]\d*|0$</code></p></li><li><p><strong>非正整数</strong>：<code>^-[1-9]\d*|0$</code></p></li><li><p><strong>非负浮点数</strong>：<code>^\d+(\.\d+)?$</code></p></li><li><p><strong>非正浮点数</strong>：<code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$</code></p></li><li><p><strong>正浮点数</strong>：<code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$</code></p></li><li><p><strong>负浮点数</strong>：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code></p></li><li><p><strong>浮点数</strong>：<code>^(-?\d+)(\.\d+)?$</code></p></li></ol><h2 id="校验字符"><a href="#校验字符" class="headerlink" title="校验字符"></a>校验字符</h2><ol><li><p><strong>汉字</strong>：<code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code></p></li><li><p><strong>英文和数字</strong>：<code>^[A-Za-z0-9]+$</code></p></li><li><p><strong>长度为3-20的所有字符</strong>：<code>^.&#123;3,20&#125;$</code></p></li><li><p><strong>由26个英文字母组成的字符串</strong>：<code>^[A-Za-z]+$</code></p></li><li><p><strong>由26个大写英文字母组成的字符串</strong>：<code>^[A-Z]+$</code></p></li><li><p><strong>由26个小写英文字母组成的字符串</strong>：<code>^[a-z]+$</code></p></li><li><p><strong>由数字和26个英文字母组成的字符串</strong>：<code>^[A-Za-z0-9]+$</code></p></li><li><p><strong>由数字、26个英文字母或者下划线组成的字符串</strong>：<code>^\w+$</code></p></li><li><p><strong>中文、英文、数字包括下划线</strong>：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></p></li><li><p><strong>中文、英文、数字但不包括下划线等符号</strong>：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code></p></li><li><p><strong>可以输入含有^%&amp;&#39;,;=?$\“等字符</strong>：<code>[^%&amp;&#39;,;=?$\x22]+</code></p></li><li><p><strong>禁止输入含有~的字符</strong>：<code>[^~\x22]+</code></p></li></ol><h2 id="其他需求"><a href="#其他需求" class="headerlink" title="其他需求"></a>其他需求</h2><ol><li><p><strong>Email地址</strong>：<code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></p></li><li><p><strong>域名</strong>：<code>[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</code></p></li><li><p><strong>URL地址</strong>：<code>^https?://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></p></li><li><p><strong>手机号码</strong>：<code>^([1][3,4,5,6,7,8,9])\d&#123;9&#125;$</code></p></li><li><p><strong>电话号码</strong>(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<code>^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</code></p></li><li><p><strong>国内电话号码</strong>(0511-4405222、021-87888822)：<code>\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</code></p></li><li><p><strong>身份证号</strong>(15位、18位数字)：<code>^\d&#123;15&#125;|\d&#123;18&#125;$</code></p></li><li><p><strong>短身份证号码</strong>(数字、字母x结尾)：<code>^([0-9])&#123;7,18&#125;(x|X)?$</code></p></li><li><p><strong>帐号是否合法</strong>(字母开头，允许5-16字节，允许字母数字下划线)：<code>^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</code></p></li><li><p><strong>密码</strong>(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<code>^[a-zA-Z]\w&#123;5,17&#125;$</code></p></li><li><p><strong>强密码</strong>(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[\da-zA-Z]&#123;8,10&#125;$</code></p></li><li><p><strong>日期格式</strong>：<code>^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</code></p></li><li><p><strong>一年的12个月</strong>(01～09和1～12)：<code>^(0?[1-9]|1[0-2])$</code></p></li><li><p><strong>一个月的31天</strong>(01～09和1～31)：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></p></li><li><p><strong>钱的输入格式</strong>：</p><ul><li><p>有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：<code>^[1-9][0-9]*$</code></p></li><li><p>这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：<code>^(0|[1-9][0-9]*)$</code></p></li><li><p>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：<code>^(0|-?[1-9][0-9]*)$</code></p></li><li><p>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：<code>^[0-9]+(.[0-9]+)?$</code></p></li><li><p>必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$</p></li><li><p>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$</p></li><li><p>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</p></li><li><p>1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</p></li><li><p>备注：这就是最终结果了,别忘了”+”可以用”*”替代，如果你觉得空字符串也可以接受的话，最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</p></li></ul></li><li><p><strong>xml文件</strong>：<code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></p></li><li><p><strong>双字节字符</strong> (包括汉字在内，可以用来计算字符串的长度，一个双字节字符长度计2，ASCII字符计1)：<code>[^\x00-\xff]</code></p></li><li><p><strong>空白行的正则表达式</strong> (可以用来删除空白行，windows的换行是\n\r，而linux和unix中换行是\n，这点需要注意)：<code>\n\s*\r</code></p></li><li><p><strong>HTML标记</strong> (仅仅能部分匹配，对于复杂的嵌套标记依旧无能为力)：<code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</code></p></li><li><p><strong>首尾空白字符</strong>(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等，非常实用)：<code>^\s*|\s*$或(^\s*)|(\s*$)</code></p></li><li><p><strong>腾讯QQ号</strong>(腾讯QQ号从10000开始) ：<code>[1-9][0-9]&#123;4,&#125;</code></p></li><li><p><strong>中国邮政编码</strong> (中国邮政编码为6位数字)：<code>[1-9]\d&#123;5&#125;(?!\d)</code> </p></li><li><p><strong>IP地址</strong> (提取IP地址时有用)：<code>(((\d&#123;1,2&#125;)|(1\d&#123;2&#125;)|(2[0-4]\d)|(25[0-5]))\.)&#123;3&#125;((\d&#123;1,2&#125;)|(1\d&#123;2&#125;)|(2[0-4]\d)|(25[0-5]))</code> 或 <code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></p></li></ol><p>参考文章： <a href="http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html">http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令总结</title>
    <link href="/2020/05/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <url>/2020/05/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>用来<strong>显示目标列表或者目录内容</strong>，常用的可选参数有：</p><ul><li><code>-a</code> 显示所有子目录和文件，包括隐藏文件</li><li><code>-l</code> 显示文件的详细信息，可以把<code>ls -l</code>简写为<code>ll</code></li></ul><h2 id="cp-mv命令"><a href="#cp-mv命令" class="headerlink" title="cp/mv命令"></a>cp/mv命令</h2><p>用来把一个文件或者多个文件<strong>复制</strong>/<strong>移动</strong>到目标目录</p><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p><strong>刪除</strong>一个目录中的一个或多个文件或目录，其中需要注意的参数有：</p><ul><li><code>-f</code> 不需要确认删除多个文件，强制删除</li><li><code>-r</code> 将文件的全部目录和子目录都删除</li></ul><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>可以<strong>显示文件内容</strong>，也可以<strong>连接</strong>两个或者多个文件</p><h2 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h2><p>显示文件的<strong>所在路径</strong></p><h2 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h2><p>用于查看Linux中的命令<strong>帮助信息</strong>，遇到不会的命令就man一下，它也有一些参数需要注意：</p><ul><li><code>-a</code> 在所有的man帮助手册中搜索；</li><li><code>-f</code> 等价于whatis指令，显示给定关键字的简短描述信息；</li></ul><h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>ps命令列出执行这个命令时刻时的那些进程，类似一个当前进程的快照，是最基本也是最强大的<strong>进程查看</strong>命令，需要注意的参数有：</p><ul><li><code>a</code> 显示所有进程</li><li><code>-a</code> 显示同一终端下的所有程序</li><li><code>-A</code> 显示所有进程</li><li><code>c</code> 显示进程的真实名称</li><li><code>e</code> 显示环境变量</li><li><code>f</code> 显示程序间的关系</li><li><code>-H</code> 显示树状结构</li><li><code>-au</code> 显示较为详细的信息</li></ul><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p>很常用的<strong>压缩</strong>&amp;&amp;<strong>解压</strong>命令了，但<code>tar</code>这个命令….参数是真的多，看到一种不错的记忆方法，只要记得参数是【必选+自选+f】即可，首先是必选参数，五选一：</p><ol><li><code>-c</code> 意为 create，表示创建压缩包</li><li><code>-x</code> 意为 extract，表示解压</li><li><code>-t</code> 表示查看内容</li><li><code>-r</code> 给压缩包追加文件</li><li><code>-u</code> 意为 update，更新压缩包中的文件</li></ol><p>然后是自选参数，必选的话只能选一个，而可以根据需要挑着选：</p><ul><li><code>-z</code> 使用 gzip 属性</li><li><code>-j</code> 使用 bz2 属性</li><li><code>-Z</code> 使用 compress 属性</li><li><code>-v</code> 意为 verbose，显示详细的操作过程</li><li><code>-O</code> 将文件输出到标准输出</li></ul><p>最后一个参数一定要是<code>f</code>，后面再跟上你要压缩或者解压的文件包名。</p><p>一般我们常用的解压方式就是：</p><ul><li><code>*.tar</code> -&gt; <code>tar -xf</code></li><li><code>*.tar.gz</code> -&gt; <code>tar -xzf</code></li><li><code>*.tar.bz2</code> -&gt; <code>tar -xjf</code></li><li><code>*.tar.Z</code> -&gt; <code>tar -xZf</code></li><li><code>*.gz</code> -&gt; <code>gzip -d</code></li><li><code>*.rar</code> -&gt; `unrar e</li><li><code>*.zip</code> -&gt; <code>unzip</code></li></ul><h2 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h2><p>用于<strong>终止指定进程</strong>的运行，对于后台进程我们可以先通过ps/pidof/pstree/top等命令获取进程PID，然后用kill结束该进程。不过也可以使用<strong>killall</strong>命令，直接使用进程的名称结束进程，使用它可以结束一组同名进程，而不用先获取进程PID，<strong>killall相当于把这两个过程合二为一</strong>，是一个很好用的命令</p><h2 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h2><p>可以用来<strong>查看一个文件的前几行</strong>，可以配合其他命令使用，例如配合管道做grep</p><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><p>tail命令和head相反，<strong>查看文件的最后几行</strong>。不过最常用的还是加上 “-f” 参数后和grep一起使用</p><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>一个极其强大的命令，常用来在很多数据中<strong>找到匹配某一模式的字段</strong>，可以是正则表达式，常用的几个参数有：</p><ul><li><code>-a</code> 以文本文件方式搜索</li><li><code>-c</code> 计算找到的符合行的次数</li><li><code>-i</code> 忽略大小写</li><li><code>-n</code> 顺便输出行号</li><li><code>-v</code> 反向选择，查找没有搜索字符串的行</li></ul><h2 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h2><p>du命令是对<strong>文件和目录磁盘使用空间的查看</strong></p><h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>用于<strong>动态的显示进程的信息</strong>，不过也有可以自定义的形式，例如:<br><code>top -u root</code>可以用来查看某用户进程</p><h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><p><strong>查找所需文件</strong>的命令，如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件，常用的参数有：</p><ul><li><code>-type</code> 只寻找符合指定的文件类型的文件,其后跟随指定文件类型参数，类型参数有<ul><li><code>f</code> 普通文件</li><li><code>l</code> 符号连接</li><li><code>d</code> 目录</li><li><code>c</code> 字符设备</li><li><code>b</code> 块设备</li><li><code>s</code> 套接字</li><li><code>p</code> FIFO</li></ul></li><li><code>-name</code> 根据文件名查找</li><li><code>-size</code> 根据文件的权限或者大小名字类型进行查找</li><li><code>-mtime</code> 查找在指定时间曾被更改过的文件或目录，单位以24小时计算；</li><li><code>-print</code> 假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出</li><li><code>-exec</code> 假设find指令的回传值为True，就执行其后跟着的指令</li></ul><h2 id="cmp命令"><a href="#cmp命令" class="headerlink" title="cmp命令"></a>cmp命令</h2><p>用来<strong>比较两个文件的差异</strong>。如果两个文件完全一样，就不会显示任何信息。如果发现有差异，会标示出第一个不同之处的字符和列数编号。</p><h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><p><strong>修改</strong>文件的创建日期，或者以当前的系统日期<strong>创建</strong>一个空文件</p><h2 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h2><p>显示<strong>当前日期和时间</strong>的，可以通过一些参数进行日期的格式化：</p><ul><li><code>%Y</code> year</li><li><code>%m</code> month (01~12)</li><li><code>%d</code> day of month</li><li><code>%H</code> hour (00~23)</li><li><code>%I</code> hour (01~12)</li><li><code>%M</code> minute (00~59)</li><li><code>%S</code> second (00~60)<br>例如：<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">date + <span class="hljs-string">&quot;%Y%m%d %H%M%S&quot;</span><br><span class="hljs-number">20180519</span> <span class="hljs-number">223856</span><br>date + <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span><br><span class="hljs-number">2018</span>-<span class="hljs-number">05</span>-<span class="hljs-number">19</span> <span class="hljs-number">22</span>:<span class="hljs-number">39</span>:<span class="hljs-number">07</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h2><p><strong>统计指定文件中的字节数、字数、行数</strong>，并将统计结果输出，需要了解的参数有：</p><ul><li><code>-c</code> 统计字节数</li><li><code>-l</code> 统计行数</li><li><code>-m</code> 统计字符数，不能与<code>-c</code>参数一起使用</li><li><code>-w</code> 统计字数</li></ul><h2 id="env-export命令"><a href="#env-export命令" class="headerlink" title="env/export命令"></a>env/export命令</h2><p><code>env</code>: <strong>查看当前环境变量</strong></p><blockquote><p>类似于配置Python环境，在一台不熟悉的机器上，如果出现了配置问题，可以通过env命令查看shell下的所有环境配置，看一下路径是否正确。</p></blockquote><p><code>export</code>:  <strong>设置或显示环境变量</strong></p><h2 id="useradd命令"><a href="#useradd命令" class="headerlink" title="useradd命令"></a>useradd命令</h2><p>useradd命令用于<strong>创建的新的系统用户</strong>。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用<strong>userdel删除帐号</strong>。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。其中有几个需要注意的参数：</p><ul><li><code>-e</code> 指定帐号的有效期限</li><li><code>-g</code> 指定用户所属的群组</li><li><code>-G</code> 指定用户所属的附加群组</li><li><code>-r</code> 建立系统帐号</li><li><code>-u</code> 指定用户id，设定ID值时尽量要大于500，以免冲突</li></ul><h2 id="groupadd命令"><a href="#groupadd命令" class="headerlink" title="groupadd命令"></a>groupadd命令</h2><p>用于<strong>创建一个新的工作组</strong>，也可以用<strong>groupdel命令删除工作组</strong>，常用的参数有：</p><ul><li><code>-g</code> 指定新建工作组的id</li><li><code>-r</code> 创建系统工作组，系统工作组的组ID小于500</li></ul><h2 id="curl-wget命令"><a href="#curl-wget命令" class="headerlink" title="curl/wget命令"></a>curl/wget命令</h2><p>curl命令是一个利用URL规则在命令行下工作的<strong>文件传输工具</strong>,而wget命令用来从指定的URL<strong>下载文件</strong>。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。</p><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><p>用来<strong>显示网络系统的状态信息</strong>，可让你了解整个系统的网络情况，需要注意的参数有：</p><ul><li><code>-a</code> 显示所有连线中的Socket</li><li><code>-n</code> 直接使用ip地址，而不通过域名服务器</li><li><code>-t</code> 显示TCP传输协议的连线状况</li><li><code>-u</code> 显示UDP传输协议的连线状况</li><li><code>-l</code> 显示监控中的服务器的Socket</li><li><code>-s</code> 显示网络工作信息统计表</li><li><code>-n</code> 直接使用ip地址，而不通过域名服务器</li></ul><p>可以通过参数的组合实现不同的功能，例如</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">netstat -<span class="hljs-keyword">at</span>    <span class="hljs-comment">#列出所有tcp端口</span><br>netstat -au    <span class="hljs-comment">#列出所有udp端口</span><br>netstat -lt    <span class="hljs-comment">#只列出所有监听 tcp 端口</span><br>netstat -lu    <span class="hljs-comment">#只列出所有监听 udp 端口</span><br>netstat -st    <span class="hljs-comment">#显示TCP端口的统计信息</span><br>netstat -su    <span class="hljs-comment">#显示UDP端口的统计信息</span><br>netstat -<span class="hljs-keyword">an</span> | grep <span class="hljs-string">&#x27;:80&#x27;</span>  <span class="hljs-comment">#找出运行在指定端口的进程</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git小记</title>
    <link href="/2020/03/16/Git%E5%B0%8F%E8%AE%B0/"/>
    <url>/2020/03/16/Git%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="设置和配置"><a href="#设置和配置" class="headerlink" title="设置和配置"></a>设置和配置</h2><ul><li><strong><code>git config</code></strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git config --global user.name &quot;xxx&quot;     # 配置用户名<br>git config --global user.email &quot;xxx@xxx.com&quot;    # 配置邮件<br>git config --global color.ui true       # git status等命令自动着色<br>git config --global color.status auto<br>git config --global color.diff auto<br>git config --global color.branch auto<br>git config --global color.interactive auto<br>git config --global --unset http.proxy  # remove  proxy configuration on git<br></code></pre></td></tr></table></figure></li></ul><h2 id="创建和获取项目"><a href="#创建和获取项目" class="headerlink" title="创建和获取项目"></a>创建和获取项目</h2><ul><li><p><strong><code>git init</code></strong><br>初始化本地git仓库（创建新仓库）</p></li><li><p><strong><code>git clone</code></strong><br>clone远程仓库</p></li></ul><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><ul><li><p><strong><code>git add</code></strong><br>应该理解为“添加内容到下一次提交中更合适”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git add xyz             # 添加xyz文件至index<br>git add .               # 增加当前子目录下所有更改过的文件至index<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git commit</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git commit -m &#x27;xxx&#x27;              # 提交并键入提交信息<br>git commit --amend -m &#x27;xxx&#x27;      # 重新尝试提交，合并上一次的提交，用于反复修改<br>git commit -am &#x27;xxx&#x27;             # 将add和commit合为一步<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git diff</code></strong><br><code>git diff</code>本身并不会显示出自上一次提交以来所有的变更，而只会显示出还没有进入暂存区的那些变更，如果所有变更已经进入暂存区，<code>git diff</code>不会有任何输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git diff                    # 显示所有未添加至index的变更<br>git diff --cached           # 显示所有已添加index但还未commit的变更<br>git diff --staged           # 将暂存的变更与上一次提交相比较<br>git diff HEAD^              # 比较与上一个版本的差异<br>git diff HEAD -- ./lib      # 比较与HEAD版本lib目录的差异<br>git diff origin/master..master          # 比较远程分支master上有本地分支master上没有的<br>git diff origin/master..master --stat   # 只显示差异的文件，不显示具体内容<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git rm</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git rm xxx                       # 删除index中的文件<br>git rm -r *                      # 递归删除<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git mv</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git mv README README2            # 重命名文件README为README2<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git status</code></strong><br>用来查看当前文件状态，查看是否进行了修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git status -s            # 更为紧凑的形式查看变更<br></code></pre></td></tr></table></figure></li></ul><h2 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h2><ul><li><p><strong><code>git log</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git log                          # 显示提交日志<br>git log -1                       # 显示1行日志 -n为n行<br>git log --stat                   # 查看每个提交的简要统计信息<br>git log -p -2                    # 显示出最近两次提交所引入的差异<br>git log v1.0                     # 显示v1.0的日志<br>git log --pretty=format:&#x27;%h %s&#x27; --graph    # 更改日志输出默认格式，其结果不会随着Git软件版本更新而改变<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git tag</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git tag                          # 显示已存在的tag<br>git tag -a v1.0 -m &#x27;xxx&#x27;         # 增加v1.0的tag<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git branch</code></strong><br>列出你所拥有的分支、创建的新分支、删除分支以及重命名分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git branch                        # 显示本地分支<br>git branch --contains 50089       # 显示包含提交50089的分支<br>git branch -a                     # 显示所有分支<br>git branch -r                     # 显示所有原创分支<br>git branch --merged               # 显示所有已合并到当前分支的分支<br>git branch --no-merged            # 显示所有未合并到当前分支的分支<br>git branch -m master master_copy  # 本地分支改名<br>git branch -d hotfixes/BJVEP933   # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）<br>git branch -D hotfixes/BJVEP933   # 强制删除分支hotfixes/BJVEP933<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git checkout</code></strong><br>切换分支并将内容检出到工作目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git checkout -b master_copy               # 从当前分支创建新分支master_copy并检出<br>git checkout -b master master_copy        # 上面的完整版<br>git checkout features/performance         # 检出已存在的features/performance分支<br>git checkout --track hotfixes/BJVEP933    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支<br>git checkout v1.0                         # 检出版本v1.0<br>git checkout -b devel origin/develop      # 从远程分支develop创建新本地分支devel并检出<br>git checkout -- README                    # 检出head版本的README文件（可用于修改错误回退）<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git merge</code></strong><br>用于将一个或多个分支合并，然后将合并的分支作为当前分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git merge origin/master            # 合并远程master分支至当前分支<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git stash</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git stash list                     # 查看所有暂存<br>git stash show -p stash@&#123;0&#125;        # 参考第一次暂存<br>git stash apply stash@&#123;0&#125;          # 应用第一次暂存<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目共享和更新"><a href="#项目共享和更新" class="headerlink" title="项目共享和更新"></a>项目共享和更新</h2><ul><li><p><strong><code>git remote</code></strong><br>用来查看已经设置了哪些远程仓库，然后列出每个远程仓库的简短名称，也可以用来管理远程仓库记录，将一段很冗杂的URL地址保存成一个简单的字符串句柄，比如origin，方便操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git remote add &lt;name&gt; &lt;url&gt;   # 增加远程定义（用于push/pull/fetch）<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git push</code></strong><br>与其他仓库通信，确定本地内容和远程仓库异同，然后将差异推送到其他仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git push origin master                   # 将当前分支push到远程master分支<br>git push origin :hotfixes/BJVEP933       # 删除远程仓库的hotfixes/BJVEP933分支<br>git push --tags                          # 把所有服务器上还没有的标记都推送过去<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git fetch</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git fetch                     # 获取所有远程分支（不更新本地分支，另需merge）<br>git fetch --prune             # 获取所有原创分支并清除服务器上已删掉的分支<br>git fetch origin              # 与服务器同步<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git pull</code></strong><br>可以理解为<code>git fetch</code>和<code>git merge</code>的组合，先从远程仓库获取内容，再尝试合并进你所在分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git pull origin master        # 获取远程分支master并merge到当前分支<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git reset</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git reset --hard HEAD         # 将当前版本重置为HEAD（通常用于merge失败回退）<br></code></pre></td></tr></table></figure></li></ul><h2 id="检视和比较"><a href="#检视和比较" class="headerlink" title="检视和比较"></a>检视和比较</h2><ul><li><p><strong><code>git show</code></strong><br>能够以简单易读的形式显示Git对象，通常用来显示标签或提交的相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git show dfb02                   # 可只用commitid的前几位<br>git show HEAD                    # 显示HEAD提交日志<br>git show HEAD^                   # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本<br>git show v1.0                    # 显示v1.0的日志及详细内容<br>git show HEAD@&#123;5&#125;<br>git show master@&#123;yesterday&#125;      # 显示master分支昨天的状态<br>git show HEAD~3<br>git show -s --pretty=raw 2be7fcb476<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git ls-files </code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git ls-files                     # 列出git index包含的文件<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git show-branch</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git show-branch                 # 图示当前分支历史<br>git show-branch --all           # 图示所有分支历史<br></code></pre></td></tr></table></figure></li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li><strong><code>git grep</code></strong><br>可以帮助你在源代码的所有文件中找到任意字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git grep &quot;delete from&quot;          # 文件中搜索文本“delete from”<br>git grep -e &#x27;#define&#x27; --and -e SORT_DIRENT<br></code></pre></td></tr></table></figure></li></ul><h2 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h2><ul><li><p><strong><code>git cherry-pick</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git cherry-pick ff44785404a8e     # 合并提交ff44785404a8e的修改<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git rebase</code></strong><br>基本上就是一个自动化的<code>git cherry-pick</code>命令，它确定一系列提交，然后在别处以相同的顺序逐个对其挑拣。不要对已经存在于本地仓库之外的提交执行rebase操作。</p></li><li><p><strong><code>git revert</code></strong><br>与<code>git cherry-pick</code>命令的效果恰好相反，将变更撤销或还原</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git revert dfb02e6e4f2f7b       # 撤销提交dfb02e6e4f2f7b<br></code></pre></td></tr></table></figure></li></ul><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><ul><li><strong><code>git reflog</code></strong><br>显示所有提交，包括孤立节点</li><li><strong><code>git gc</code></strong><br>执行”垃圾回收“，删除无用文件，将余下的文件打包成一种更有效的形式</li><li><strong><code>git fsck</code></strong><br>用于检查内部数据库存在的问题或不一致性</li></ul><h1 id="Git使用规范流程"><a href="#Git使用规范流程" class="headerlink" title="Git使用规范流程"></a>Git使用规范流程</h1><blockquote><p>在团队开发中，遵循一个合理、清晰的规范是很重要的，例如Git,如果每个人都很随意的提交一堆commit，项目很快就会变得难以维护和管理了，所以需要规范化这个流程。</p></blockquote><h2 id="一、新建分支"><a href="#一、新建分支" class="headerlink" title="一、新建分支"></a>一、新建分支</h2><p>每次开发一个新的功能，我们都应该新建一个单独的分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs (git)"># 获取最新代码<br>git checkout master<br>git pull<br><br># 新建一个开发分支<br>git checkout mybranch<br></code></pre></td></tr></table></figure><h2 id="二、提交分支"><a href="#二、提交分支" class="headerlink" title="二、提交分支"></a>二、提交分支</h2><p>分支修改后，就可以提交了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git add .<br>git status<br>git commit<br></code></pre></td></tr></table></figure><h2 id="三、撰写提交信息"><a href="#三、撰写提交信息" class="headerlink" title="三、撰写提交信息"></a>三、撰写提交信息</h2><p>提交commit时，必须要简洁明了的叙述提交的信息，可以参考这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs (git)">简要的变更汇总，然后空一行（不超过50个字符），如果有必要，就要附加更详细的说明，每行长度限制在72个字符左右。<br><br>- 通常使用连字符或者星号作为条目符号<br>- 改动原因<br>- 主要变动<br>- 需要注意的问题<br></code></pre></td></tr></table></figure><h2 id="四、与主分支同步"><a href="#四、与主分支同步" class="headerlink" title="四、与主分支同步"></a>四、与主分支同步</h2><p>开发的过程中要时常与主分支保持同步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git fetch origin<br>git rebase origin/master<br></code></pre></td></tr></table></figure><h2 id="五、合并"><a href="#五、合并" class="headerlink" title="五、合并"></a>五、合并</h2><p>开发完成后，我们需要把一堆commit合并到主分支<br>关于合并多个commit,可以看这篇文章：<a href="https://www.jianshu.com/p/964de879904a">「Git」合并多个 Commit</a><br>不过也有一种简洁的合并方式,就是先撤销过去5个commit，然后再建一个新的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git reset HEAD~5<br>git add .<br>git commit -am &quot;Here&#x27;s the bug fix that closes #28&quot;<br>git push --force<br></code></pre></td></tr></table></figure><h2 id="六、推送远程仓库"><a href="#六、推送远程仓库" class="headerlink" title="六、推送远程仓库"></a>六、推送远程仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs (git)">git push --force origin myfeature<br></code></pre></td></tr></table></figure><p>之所以要加上 force 参数，是因为 rebase 后，分支历史改变引起的远程分支不兼容问题</p><h2 id="七、发出Pull-Request"><a href="#七、发出Pull-Request" class="headerlink" title="七、发出Pull Request"></a>七、发出Pull Request</h2><p>提交完毕后，就可以发出 Pull Request 到 master 分支，然后请求别人进行代码 review ，确认是否可以合并到 master 分支。</p><h1 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h1><h2 id="主流工作流"><a href="#主流工作流" class="headerlink" title="主流工作流"></a>主流工作流</h2><ul><li>Git Flow</li><li>GitHub Flow</li><li>GitLab Flow</li></ul><h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><p>Git Flow 是最早诞生、并得到广泛采用的一种工作流程。 Git Flow 存在两个长期分支，分别是主分支 master 和开发分支 develop ，前者是对外发布的稳定版本，后者相当于测试开发版，用于日常开发使用。</p><p>Git Flow还有三个协助分支，分别是功能分支（分模块功能开发）、补丁分支（线上的紧急 bug 修复）、和预发分支（版本发布的预发布），分别对应不同的业务需求，一旦开发完成，它们会先合并进开发分支，再合并进主分支，或者直接并入主分支。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/Git%E5%B0%8F%E8%AE%B02.png" alt="Git小记2"></p><p>Git Flow的优点在于直观明了，易于控制，但需要维护两个长期分支，需要频繁切换，而且这个模式更多基于“版本发布”的，对于一些“持续发布”的项目，两个长期分支的区别就不大，没必要都维护。</p><h2 id="GitHub-Flow"><a href="#GitHub-Flow" class="headerlink" title="GitHub Flow"></a>GitHub Flow</h2><p>GitHub Flow 作为 Github 所使用的工作流，其目的也是专门为了配合“持续发布”的。它只有一个长期分支，就是我们所熟知的 master 分支，团队成员们的分支代码通过 Pull Request 来合并到 master 上。</p><p>我们通过从 mater 上拉出新的分支，当开发完成时，就发起一个Pull Request，然后会审核你的代码，如果被接受就可以合并进 master 分支。</p><p>不过由于它只有一个主分支，所以如果你的开发时间很长，主分支就会与你得分支版本不一致，而你不得不专门建一个分支跟踪线上的新版本。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/Git%E5%B0%8F%E8%AE%B03.png" alt="Git小记3"></p><h2 id="GitLab-Flow"><a href="#GitLab-Flow" class="headerlink" title="GitLab Flow"></a>GitLab Flow</h2><p>Gitlab flow 吸取了 Git flow 与 Github flow 的优点。既有适应不同开发环境的弹性，又有单一主分支的简单和便利。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/Git%E5%B0%8F%E8%AE%B04.png" alt="Git小记4"></p><p>对于”持续发布”的项目，建议在 master 分支以外，再建立不同的环境分支。比如，”开发环境”的分支是 master ，”预发环境”的分支是 pre-production ，”生产环境”的分支是 production 。</p><p>开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。只有上游没有问题，才能发布到下游，除非是紧急情况，才能直接合并到下游分支。</p><p>对于”版本发布”的项目，都要从 master 分支拉出一个分支，比如1-3-stable、1-4-stable等等。发现问题，就从对应版本分支创建修复分支，完成之后，先合并到 master，才能再合并到 release 分支，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/Git%E5%B0%8F%E8%AE%B05.png" alt="Git小记5"></p><h1 id="Git代码规范"><a href="#Git代码规范" class="headerlink" title="Git代码规范"></a>Git代码规范</h1><br/>具体可以看一下这篇文章：[Git Style Guide](https://github.com/agis/git-style-guide)]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown小记</title>
    <link href="/2020/01/05/Markdown%E5%B0%8F%E8%AE%B0/"/>
    <url>/2020/01/05/Markdown%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><ul><li>如果你需要插入标题，可以在行首插入1到6个#，对应标题的1到6级,最高可以到六级标题，最好在#后加一个空格，例如:</br><br><code># 这是一级标题</code></br><br><code>## 这是二级标题</code></br><br><code>####### 这是六级标题</code></li><li>也可以使用<code>=====</code>表示高级标题，使用<code>------</code>表示次级标题，大于两个<code>=</code>,<code>-</code>都可以用来表示标题</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果你需要一个引用，那么你可以使用<code>&gt;</code>符号放在文字开头，例如:</br><br><code>&gt;这是一个引用</code></br><br>引用是可以嵌套的，同时引用的区块内部也可以使用其他的Markdown语法，例如</br></p><blockquote><p>这是一个引用</p><blockquote><p>这是一个嵌套引用</p></blockquote><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><ol><li>列表项</li><li>列表项</li></ol></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>如果你需要一个列表，在Markdown里，你可以选择有序列表和无序列表两种形式，列表本身也是可以嵌套，例如</p><ul><li>列表项</li><li>列表项</li><li>列表项<ul><li>嵌套列表</li><li>嵌套列表</li></ul></li></ul><p>无序列表可以使用<code>*</code>、<code>+</code>、<code>-</code>这三个符号中的任意一种作为列表标记，也可以和引用标记进行嵌套</p><ol><li>列表项</li><li>列表项</li><li>列表项<blockquote><p>这是一个嵌套的引用</p><blockquote><p>可以进一步嵌套</p></blockquote></blockquote></li></ol><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul><li><strong>粗体</strong>: 通常用<code>**</code>或者<code>__</code>表示粗体</li><li><em>斜体</em>: 通常用<code>*</code>或者<code>_</code>表示斜体</li><li><em><strong>斜粗体</strong></em>：通常用<code>***</code>或者<code>___</code>表示斜粗体</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>如果你需要链接文字，可以使用<code>[](link)</code>表示一个链接，其中<code>[]</code>内是需要添加链接的文字，<code>()</code>内是链接的地址</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>使用一对```表示代码块，可以根据你所使用的Markdown编辑器,选择在第一个```后添加代码的language，产生高亮效果，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>使用一对 <code> 可以表示一个行内代码，例如： 这是一个</code>Java`代码</li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>如果你需要插入一张图片，可以使用<code>![Text](path)</code>，其中Text表示图片无法加载时显示的文字，path为图片所在的路径，也可以是网上的图片链接地址</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>如果你需要一条分割线，可以使用<code>---</code> 或者<code>***</code>表示水平分割线，只要<code>-</code>,<code>*</code>大于三个就可以表示水平分割线，使用<code>---</code>作分割线时需要前后都空一行，防止被当成标题的标记方式</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>如果你需要一条<del>删除线</del>,可以使用一对<code>~~</code>表示删除线，但切记和文字之间不能有空格</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>可以使用以下的格式添加表格,注意表格和文字间空一行：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">| name  | age | gender    | money  |<br>|-------|<span class="hljs-symbol">:---</span><span class="hljs-symbol">:|-----------|-------</span><span class="hljs-symbol">:|</span><br>| rhio  | <span class="hljs-number">384</span> | robot     | <span class="hljs-variable">$3</span>,000 |<br>| haroo | .<span class="hljs-number">3</span>  | bird      | <span class="hljs-variable">$430</span>   |<br>| jedi  | ?   | undefined | <span class="hljs-variable">$0</span>     |<br></code></pre></td></tr></table></figure><table><thead><tr><th>name</th><th align="center">age</th><th>gender</th><th align="right">money</th></tr></thead><tbody><tr><td>rhio</td><td align="center">384</td><td>robot</td><td align="right">$3,000</td></tr><tr><td>haroo</td><td align="center">.3</td><td>bird</td><td align="right">$430</td></tr><tr><td>jedi</td><td align="center">?</td><td>undefined</td><td align="right">$0</td></tr></tbody></table></br><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果 Markdwon 的语法达不到预期效果，或者一些地方的处理用 Markdwon 的格式无法实现，可以考虑用 HTML 和 CSS</p><ul><li>引用<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span>***<span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br>/* 如果上下间距小，可以这样写 */<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span>***<span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>居中和右对齐<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs (html)">/* 居中 */<br>&lt;center&gt;**&lt;/center&gt;<br>/* 右对齐 */<br>&lt;p style=&quot;text-align:right&quot;&gt;**&lt;/p&gt;<br>/* 右对齐 */<br>&lt;p style=&quot;text-align:left&quot;&gt;**&lt;/p&gt;<br></code></pre></td></tr></table></figure></li><li>字体大小和颜色<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;#xxxxxx&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;number&quot;</span>&gt;</span>**<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>分割线和空行<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br></code></pre></td></tr></table></figure></li></ul><div class="note info"><p>关于Markdown的更多细节，可以参看：[Markdown 语法说明 (简体中文版)](https://www.appinn.com/markdown/)，对于Markdown的规范，可以看一下 ：[Google Markdown Style Guide](https://github.com/google/styleguide/blob/gh-pages/docguide/style.md) 或者 [Markdown Style Guide](http://www.cirosantilli.com/markdown-style-guide/)</p></div>]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
