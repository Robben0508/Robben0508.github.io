{"meta":{"title":"世宇的小站","subtitle":"","description":"","author":"Oliver Sheng","url":"https://www.shengshiyu.com","root":"/"},"pages":[{"title":"about","date":"2021-09-25T13:09:15.000Z","updated":"2021-09-27T08:51:02.510Z","comments":false,"path":"about/index.html","permalink":"https://www.shengshiyu.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Electron+Vue的使用","slug":"Electron+Vue的使用","date":"2021-03-03T13:34:00.000Z","updated":"2021-09-27T08:51:02.510Z","comments":true,"path":"2021/03/03/Electron+Vue的使用/","link":"","permalink":"https://www.shengshiyu.com/2021/03/03/Electron+Vue%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"关于Electron使用Electron可以很方便的创建跨平台桌面端的Web程序，而提到Electron就不得不提到Node.js,因为Electron用Node做后台，只要你需要通过Electron来访问网络或是硬盘，就得依靠Node，而Electron也使用Node来管理依赖项，你只需要使用npm install命令便可很方便的为你的Electron添加不同的依赖库。 所以创建一个Electron项目的第一步便是安装Node的环境，无论你是macOS还是Windows，比较简单的方式便是使用Node官网提供的安装包，你只需要去下载相应版本的安装包即可，建议安装LTS版本，下载好后根据安装向导完成安装便完成安装了。 如果你需要下载特定版本的Node.js，可以在官网下方找到Node的所有历史版本，根据需要下载即可。 创建第一个Electron程序在Electron官网上我们可以通过其electron-quick-start项目来作为基础进行构建，通过： 12345678# 克隆示例项目的仓库$ git clone https://github.com/electron/electron-quick-start# 进入这个仓库$ cd electron-quick-start# 安装依赖并运行$ npm install &amp;&amp; npm star 然后我们就可以通过npm start来启动我们的electron项目了！ 上手Vue,搭建Vue环境搭建Vue的开发环境我们需要用到Vue的脚手架工具vue-cli，由于vue-cli2.X版本要淘汰了，所以我们需要使用vue-cli3.0及其以上的版本进行项目的创建，2.X的vue-cli你只需要通过npm install -g vue-cli命令即可安装，但3.0及其以上版本的vue-cli你只能通过npm install -g @vue/cli，注意，它的库的名字改为了**@vue/cli**，然后我们就可以开始使用vue-cli创建一个Vue项目了，运行如下命令 1vue create my-first-demo 根据需要选择相应配置，完成如图： 然后进入项目目录，通过 12cd my-first-demonpm run serve // 如果是yarn的话，就是yarn serve 启动后如图： 可以通过执行命令 1npm run build 来对项目进行构建生成，完成后项目目录下会生成一个dist文件夹。 项目文件结构如图： 引入Electron在Vue项目中引入Electron的方式有很多，我们可以直接执行命令npm install electron来安装Electron，然后通过在dist文件夹内创建主程序的入口文件main.js和相关配置文件package.json的方式来引入electron。 可以参考：手把手教Electron+vue的使用 当然也可以通过脚手架工具，例如electron-vue，或者通过Vue插件Vue CLI Plugin Electron Builder 来实现，考虑到electron-vue这个脚手架工具很久没更新了，其中的electron版本还是2.X的，还得手动替换很多东西，不是很方便，但感兴趣的同学可以参考他的官方文档，这里我们使用Vue CLI Plugin Electron Builder。 注意，如果你的vue-cli还是2.X版本的话，你需要卸载它，然后安装3.X以上的版本进行创建，否则你是使用不了Vue CLI Plugin Electron Builder的。 首先，我们先进入之前建立好的Vue项目，然后按以下命令安装并调用vue-cli-plugin-electron-builder的生成器： 12cd my-first-demovue add electron-builder 注意，期间根据你的情况选择相应electron版本，这里我选择的是electron5.0的版本，根据你本地的Node.js版本你可以选择更高版本。 安装好后可以打开package.js文件可以发现electron已经成功引入 接下来我们通过运行命令，来让我们的项目跑起来 1npm run electron:serve 如图所示，一个简单的Electron程序就成功运行起来了 打开之前的项目目录，可以看到项目目录下多了一个dis_electron文件夹，其中也有一个package.json文件，指定在src目录下background.js为Electron入口文件，其作用和之前手动添加main.js和package.json的方式一样。 下面我们通过构建命令： 1npm run electron:build 完成后在dist_electron文件夹下就可以看到我们生成的Windows平台的安装程序 如果需要生成macOS或是Linux平台的安装包，可以阅读electron的官方文档，获取更进一步的详细配置。 注意，可能在过程中由于网络问题，我们可能会构建失败，所需要的依赖文件可以通过以下几个办法来解决。 1.设置淘宝镜像 1npm set ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/ 设置好后所需要的依赖文件就应该可以下载好了 2.手动添加 如果设置淘宝镜像还是不行的话可以在 https://npm.taobao.org/mirrors/electron 中找到提示中你所需的对应版本的文件，当然还有几个文件需要我们前往对应网站去下载对应版本的包才行 winCodeSign nsis nsis-resources 下载对应文件后，解压到C:\\Users\\你的用户名\\AppData\\Local\\electron\\Cache中，或是C:\\Users\\Administrator\\AppData\\Local\\electron-builder\\cache下的不同的依赖文件夹里，根据所需版本在里面创建新的文件夹,文件夹名字需要和npm run build里要求下载的文件名一致，例如 nsis-resources-3.3.0 后面的版本要对应上。 完成上述配置后，再次运行npm run electron:build便不会再报错。","categories":[{"name":"Technology","slug":"Technology","permalink":"https://www.shengshiyu.com/categories/Technology/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.shengshiyu.com/tags/Vue/"},{"name":"Electron","slug":"Electron","permalink":"https://www.shengshiyu.com/tags/Electron/"}]},{"title":"关于JavaScript的闭包","slug":"关于Javascript的闭包","date":"2020-09-05T00:00:00.000Z","updated":"2021-09-27T08:51:02.510Z","comments":true,"path":"2020/09/05/关于Javascript的闭包/","link":"","permalink":"https://www.shengshiyu.com/2020/09/05/%E5%85%B3%E4%BA%8EJavascript%E7%9A%84%E9%97%AD%E5%8C%85/","excerpt":"","text":"变量作用域理解闭包的前提是理解JavaScript的变量作用域，变量的作用域分为全局变量和局部变量， JavaScript具有基于函数的作用域，每声明一个函数都会为其自身创建一个自己的执行环境，而且在函数内部就可以直接访问全局变量。 12345var a = 1function func1()&#123; console.log(a);&#125;func1(); // 1 但是在函数外是无法访问函数内的局部变量的。不过如果不使用var关键字，就会在内部作用域声明一个全局变量。 1234function func1()&#123; var a = 1&#125;console.log(a); // error 这里就涉及到一个问题，假如我们需要读取函数内部的变量怎么办？于是我们只能在函数的内部再定义一个函数。 123456789function func1()&#123; var a = 1 function func2()&#123; console.log(a); &#125; return func2;&#125;var n = func1();n(); // 1 此时，func1内的所有局部变量对于func2来说都是可见的，func1的返回值，也就是func2（），赋值给变量n，然后调用n(),实际只是通过不同的标识符来引用调用了内部的函数func2(). 闭包说了半天，那么闭包到底是啥，我的理解是：闭包就是函数的局部变量的集合，能够读取其他函数的局部变量，只有定义在函数内部的子函数才可以获取局部变量，当一个函数定义在另一个函数内，并且试图通过子函数获得局部变量，它就是闭包。 闭包使得函数内部作用域和函数外部作用域的连接成为了可能，局部变量可以在函数返回后被访问，而且闭包里变量的值可以始终保持在内存中，我们可以通过一个例子来看： 123456789101112131415function func1()&#123; var n=1; Add = function()&#123; n += 1 &#125; function func2()&#123; console.log(n); &#125; return func2;&#125;var result = func1();result(); // 1Add();result(); // 2 可以看到局部变量n一直保存在内存中，不会随着函数调用的结束而被垃圾回收，func2是func1的子函数，但作为func1的返回值，却被赋值给了一个全局变量result，这就使得func2始终在内存中，因为func2的存在依赖于func1，所以func1也就跟着保存在了内存中。 前面提到，如果不使用var关键字，会在内部声明一个全局变量，所以Add就是一个全局变量，但它可以在函数外部对内部的局部变量进行操作，实则它也是一个闭包。 过渡的使用闭包，内存消耗会很大，但闭包的用处也很多，在定时器、事件监听器、Ajax 请求、跨窗口通信或者任何其他的异步或者同步任务中，只要使用了回调函数，实际上就是在使用闭包。","categories":[{"name":"Technology","slug":"Technology","permalink":"https://www.shengshiyu.com/categories/Technology/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengshiyu.com/tags/JavaScript/"}]},{"title":"关于JavaScript中的继承机制","slug":"关于Javascript中的继承机制","date":"2020-08-21T00:00:00.000Z","updated":"2021-09-27T08:51:02.510Z","comments":true,"path":"2020/08/21/关于Javascript中的继承机制/","link":"","permalink":"https://www.shengshiyu.com/2020/08/21/%E5%85%B3%E4%BA%8EJavascript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"原型链传统的面向对象语言里，基本都支持继承的两种方式：接口继承和实现继承。接口继承继承方法签名，而实现继承则继承实际的方法。至于JavaScript里的继承，由于函数没有签名，只能支持实现继承，而且主要通过原型链来实现的。每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例又都包含一个指向原型对象的内部指针，通过使用原型，将方法添加在”父类“的原型里，然后”子类“的原型就是父类的一个实例化对象。 1SubClass.prototype = new SuperClass() ; 如此层层递进，就构成了实例与原型的链条，这就是原型链。但原型链也有问题，原先实例的属性会在这个继承的过程中顺理成章的成为其“子类”的原型属性。而且创建的”子类“的实例，无法在不影响所有对象实例的情况下，像”超类“的构造函数传递参数，于是有了构造函数继承。 构造函数继承构造函数继承的核心思想就是SuperClass.call(this),通过call()和apply()方法，在新创建的对象上执行构造函数，然后改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费的问题。 123456function SuperClass()&#123; this.colors = [&quot;read&quot;,&quot;blue&quot;,&quot;yellow&quot;];&#125;function SubClsss()&#123; SuperClass.call(this);&#125; 组合式继承组合式继承，也叫作伪经典继承，结合了前两者的特点，既不会使每个实例化的“子类”互相影响，也避免了内存的浪费。它使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。既可以在原型上定义方法实现实现函数复用，又能保证每个实例都有它自己单独的属性。 123456789101112131415161718192021function SuperClass()&#123; this.name = name; this.colors = [&quot;read&quot;,&quot;blue&quot;,&quot;yellow&quot;];&#125;SuperClass.prototype.sayName = function()&#123; console.log(this.name);&#125;function SubClass(name, age)&#123; //继承属性 SuperClass.call(this, name); this.age = age&#125;//继承方法SubClass.prototype = new SuperClassSubClass.prototype.constructor = SubClass;SubClass.prototype.sayAge = function() &#123; console.log(this.age);&#125; 寄生式继承寄生式继承的思路是创建一个仅用于封装继承过程的函数，该函数的内部以某种方式来增强对象，然后返回对象，就像所有都是它做的一样，很像工厂模式。 12345678function MyClass(original)&#123; //通过调用函数创建一个新对象 var clone = object(original); clone.sayHello = function() &#123; console.log(&quot;Hello&quot;); &#125;; return clone;&#125; 不过使用这种模式来为对象添加函数，会因为不能做到函数复用而降低效率，所以出现了寄生组合式继承。 寄生组合式继承组合式继承的方法固然好，但是会导致一个问题，父类的构造函数会被创建两次（call()的时候一遍，new的时候又一遍），所以为了解决这个问题，又出现了寄生组合继承。集寄生式继承和组合继承的优点于一身，本质上就是使用寄生式继承来继承“超类”的原型，然后再将结果指定给“子类”的原型。 123456789101112131415161718192021222324function inheritObject(subClass,superClass) &#123; //复制一份父类的原型保存在变量中 var p = inheritObject(superClass.prototype); //修正因为重写子类原型导致子类constructor属性被修改 p.constructor = subClass; //设置子类的原型 subClass.prototype = p; &#125; //定义父类var SuperClass = function (name) &#123; this.name = name; this.books = [&#x27;javascript&#x27;,&#x27;html&#x27;,&#x27;css&#x27;] &#125;;//定义父类原型方法SuperClass.prototype.getBooks = function () &#123; console.log(this.books)&#125;;//定义子类var SubClass = function (name) &#123; SuperClass.call(this,name)&#125;inheritObject(SubClass,SuperClass);var subclass1 = new SubClass(&#x27;Java&#x27;)","categories":[{"name":"Technology","slug":"Technology","permalink":"https://www.shengshiyu.com/categories/Technology/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengshiyu.com/tags/JavaScript/"}]},{"title":"JavaScript中this的原理","slug":"JavaScript中this的原理","date":"2020-08-17T23:24:00.000Z","updated":"2021-09-27T08:51:02.510Z","comments":true,"path":"2020/08/17/JavaScript中this的原理/","link":"","permalink":"https://www.shengshiyu.com/2020/08/17/JavaScript%E4%B8%ADthis%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"关于this为啥要有这个关键字呢？如果不使用this，我们在写代码时就需要显示的传入上下文对象。会很麻烦，随着代码量的增多，会使代码变得混乱，而this可以隐式“传递”一个对象的引用，利于代码复用，因为它会动态的判断上下文环境，然后引用合适的上下文对象。 我们可能会在学习时产生片面的误解，一种是我们认为this指向函数自身，另一种是我们认为this指向函数的作用域。因为在一些情况下，它们是对的，但有时却是错误的，举例来说： 12345678function foo() &#123;var a = 2;this.bar();&#125;function bar() &#123;console.log( this.a );&#125;foo(); // ReferenceError: a is not defined 如果按之间的观点，那这段代码应该能正确调用，但实则不能，可见this关键字不是我们之前想的那样。 this是什么 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。 this 就是记录的其中一个属性，会在函数执行的过程中用到。 理解this的前提，我们需要知道什么叫做调用位置，调用位置就是函数在代码中被调用的位置，而不是声明的位置，通过调用位置我们才好判断this究竟引用的是什么。 this的指向this永远指向最后调用它的那个对象，通过这句话就能很容易判断this的指向，因为调用位置就在当前正在执行的函数的前一个调用中。 默认绑定12345function foo() &#123;console.log( this.a );&#125;var a = 1;foo(); // 1 我们可以看到，最后调用foo()的地方，它的前面没有明显的调用对象，所以就是全局对象window，相当于window.foo()那么this的指向就是就是window这个全局对象，所以window.a的值就是1。这是默认的绑定情况。 隐式绑定我们有时候还要考虑调用位置是否具有上下文对象，可以看一个例子： 12345678function foo() &#123;console.log( this.a );&#125;var obj = &#123;a: 1,foo: foo&#125;;obj.foo(); // 1 这就简单了，因为this永远指向最后调用它的那个对象，最后调用它的是obj，所以就相当于obj.a，所以值为1，下面是另一种情况，可能我们调用时是在一个属性引用链上： 123456789101112function foo() &#123;console.log( this.a );&#125;var obj2 = &#123;a: 2,foo: foo&#125;;var obj1 = &#123;a: 1,obj2: obj2&#125;;obj1.obj2.foo(); // 2 不用在意obj1，这里我们要强调“最后调用”，所以最后调用的是obj2，obj1先调用obj2，obj2再调用foo(),所以结果就是obj2.a，所以值为2。 但假如我们给函数起了别名，可以通过一个例子看一下： 12345678910function foo() &#123;console.log( this.a );&#125;var obj = &#123;a: 1,foo: foo&#125;;var bar = obj.foo; // 函数别名！var a = &quot;hello&quot;; // a 是全局对象的属性bar(); // &quot;hello&quot; 虽然我们将 obj 对象的 foo 方法赋值给变量 bar 了，但是没有调用，所以bar()最后还是被全局对象window调用了，this的指向就是window，就相当于window.a，所以值为hello。 不过我们需要尤为注意回调函数里的this的指向问题，因为回调函数里我们传入的函数，实际上它相当于给里面的形参取了一个别名。当我们分析this的指向时，它实际的指向会被误导，但实质上它还是指向最后调用它的那个对象。 显式绑定如果我们想在某个对象上强制调用函数，可以直接指定this指向的对象，什么意思呢，我们先看一个例子： 12345678function foo() &#123;console.log( this.a );&#125;var obj = &#123;a:1&#125;;var a = 2;foo.call( obj ); // 1 我们通过call()函数，将obj的作用域传递进了foo中，因为JavaScript存在一个作用域链，相当于我们window.obj.foo(),所以最后调用的是obj对象，所以值为1。我们把foo的this绑定到了obj上。也可以通过apply()和bind()方法。 new绑定12345function foo(a) &#123;this.a = a;&#125;var bar = new foo(1);console.log( bar.a ); // 1 使用new来调用foo()时，我们会构造一个新对象，这个新对象会绑定到foo()调用中的this上，所以bar.a的值就是1，和隐式绑定里的取别名是不一样的，它依然指向最后调用它的那个对象。 箭头函数ES6里，我们可以使用箭头函数始终指向函数定义时的this，不用担心执行时改变，在箭头函数里也没有this绑定了，上面四条绑定原则也不存在了，要根据作用域链来决定它的值，箭头函数会继承外层函数调用的 this 绑定。 12345678910111213var a = &quot;hello&quot;;var ogj = &#123; b : &quot;hi&quot; func1: function () &#123; console.log(this.b); &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;obj.func2() // hi 总结总之，我们要记住”this永远指向最后调用它的那个对象“，具体绑定的方式，如果是由new调用，那它就绑定到了新创建的对象上，如果由call()、apply()、bind()调用，那么就是在绑定的那个对象上，如果包含上下文调用的隐式绑定，要注意上下文对象，如果包含回调函数，要格外小心。如果使用了箭头函数，注意根据作用域链来决定“this”的指向。","categories":[{"name":"Technology","slug":"Technology","permalink":"https://www.shengshiyu.com/categories/Technology/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengshiyu.com/tags/JavaScript/"}]},{"title":"正则表达式小记","slug":"正则表达式小记","date":"2020-07-03T21:55:00.000Z","updated":"2021-09-27T08:51:02.510Z","comments":true,"path":"2020/07/03/正则表达式小记/","link":"","permalink":"https://www.shengshiyu.com/2020/07/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"关于正则表达式正则表达式是为了从大量数据中检索匹配出所需数据的一种强有力的工具，它赋予使用者描述和分析文本的能力，如果没有正则表达式，我们也可以实现同样的功能，只是需要通过循环遍历，通过大量的条件判断才能得到想要的结果。而正则表达式只需要简单的而命令，就能够检索所有文件。 常用元字符“ . “: 使用.字符匹配任意单个字符、字母、数字或者.字符本身，不过要在.的前面加上 \\ ，对它进行转义，匹配其他元字符也一样。“^”: 使用^会匹配行或者字符串的起始位置“$”: 使用$会匹配行或者字符串的末位“\\d”: 匹配数字，如果是匹配非数字字符，只用把d大写就行\\D“\\w”: 匹配字母数字和下划线，等价于[a-zA-Z0-9_],如果是匹配非字母数字或下划线字符，只用把w大写就行\\W“\\s”: 匹配空白字符，如果是匹配非空白字符，只用把s大写就行\\S“\\b”: 匹配一个单词的开始或是结尾，这个“单词”在正则表达式看来就是一个与\\w相匹配的字符和一个与\\W相匹配的字符之间的位置，它只匹配一个位置，不匹配任何字符，\\B表示不匹配一个单词的边界“ [ ] “: 只匹配括号内定义的字符集合，字符集合可以按字符区间来表示区间内所有字符，以下是一些合法的字符区间例子: A-Z 匹配A到Z的所有大写字母 a-z 匹配A到Z的所有小写字母 A-z 匹配ASCII字符A到ASCALL字符z的所有字符，其中也包含[或是^等类似字符，可能匹配到多余结果。 POSIX字符类POSIX字符类是一种正则表达式的简写形式，可以通过元字符和POSIX字符类的组合来简化正则表达式。 重复匹配正则表达式可以进行重复匹配，匹配多个连续出现的字符或者字符集。 “ * “：匹配零次或多次例如：a*会匹配到所有的字符或字符集为”a”的情况 “ + “：匹配一次或多次，至少一次例如：a+会匹配到字符或字符集中为”a”的情况，a+与a*不同在于”+”至少是一次而”*” 可以是0次 “ ? “：匹配零次或一次例如：a?只会匹配一次，也就是结果可能只有单个字符a “{n}”：重复n次匹配例如：a&#123;3&#125;结果就是匹配到满足3个a字符的情况 “aaa” “{n,m}”：重复n到m次匹配例如：a&#123;2,3&#125; 将a重复匹配2次或者3次 所以匹配到的字符可以是两个”aa”也可以是三个”aaa” “{n,}”：重复n次或更多次匹配，至少匹配n次 子表达式子表达式是为了解决一些特殊匹配情况下使用的，使用一对圆括号把正则表达式括起来，按我的理解，其实它就是解决一个优先级和整体匹配的问题，类似于C语言里的双括号，为了显式增强操作符优先级顺序，避免混乱。 举个例子：&amp;nbsp;&#123;2,4&#125; 这个正则表达式的原意是为了匹配&amp;nbsp两次到四次，但实际{2,4}只作用于它的前一个字符，相当于它只会匹配到&amp;nbsp;; 、 &amp;nbsp;;; 、 &amp;nbsp;;;;。 所以引入了子表达式，(&amp;nbsp;)&#123;2,4&#125;这样就能按我们预期的结果进行匹配了，它会把&amp;nbsp;看成一个整体进行匹配。 子表达式也是可以进行嵌套使用的，但我们要尽量避免嵌套次数过多引起的逻辑混乱，阅读困难。 常见问题的正则表达式这里是一些网上搜集的常见的正则表达式匹配的例子，学习正则表达式最好的方式就是多练习多思考，通过这些简单的例子作为参考来学习，由浅入深，而不是直接复制拿来用，真正掌握了正则表达式才能灵活应对各种情况。它仅仅是一个方法的参考，而非方法本身。 检验数字 数字：^[0-9]*$ n位的数字：^\\d&#123;n&#125;$ 至少n位的数字：^\\d&#123;n,&#125;$ m - n位的数字：^\\d&#123;m,n&#125;$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ 带1 - 2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$ 有1 - 3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$ 非零的正整数：^[1-9]\\d*$ 非零的负整数： ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 非负浮点数：^\\d+(\\.\\d+)?$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 校验字符 汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$ 英文和数字：^[A-Za-z0-9]+$ 长度为3-20的所有字符：^.&#123;3,20&#125;$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 可以输入含有^%&amp;&#39;,;=?$\\“等字符：[^%&amp;&#39;,;=?$\\x22]+ 禁止输入含有~的字符：[^~\\x22]+ 其他需求 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? URL地址：^https?://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^([1][3,4,5,6,7,8,9])\\d&#123;9&#125;$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$ 国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125; 身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$ 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[\\da-zA-Z]&#123;8,10&#125;$ 日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代，如果你觉得空字符串也可以接受的话，最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 双字节字符 (包括汉字在内，可以用来计算字符串的长度，一个双字节字符长度计2，ASCII字符计1)：[^\\x00-\\xff] 空白行的正则表达式 (可以用来删除空白行，windows的换行是\\n\\r，而linux和unix中换行是\\n，这点需要注意)：\\n\\s*\\r HTML标记 (仅仅能部分匹配，对于复杂的嵌套标记依旧无能为力)：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt; 首尾空白字符(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等，非常实用)：^\\s*|\\s*$或(^\\s*)|(\\s*$) 腾讯QQ号(腾讯QQ号从10000开始) ：[1-9][0-9]&#123;4,&#125; 中国邮政编码 (中国邮政编码为6位数字)：[1-9]\\d&#123;5&#125;(?!\\d) IP地址 (提取IP地址时有用)：(((\\d&#123;1,2&#125;)|(1\\d&#123;2&#125;)|(2[0-4]\\d)|(25[0-5]))\\.)&#123;3&#125;((\\d&#123;1,2&#125;)|(1\\d&#123;2&#125;)|(2[0-4]\\d)|(25[0-5])) 或 ((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 参考文章： http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html","categories":[{"name":"Technology","slug":"Technology","permalink":"https://www.shengshiyu.com/categories/Technology/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.shengshiyu.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Linux常用命令总结","slug":"Linux常用命令总结","date":"2020-05-19T21:43:08.000Z","updated":"2021-09-27T08:51:02.510Z","comments":true,"path":"2020/05/19/Linux常用命令总结/","link":"","permalink":"https://www.shengshiyu.com/2020/05/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/","excerpt":"","text":"ls命令用来显示目标列表或者目录内容，常用的可选参数有： -a 显示所有子目录和文件，包括隐藏文件 -l 显示文件的详细信息，可以把ls -l简写为ll cp/mv命令用来把一个文件或者多个文件复制/移动到目标目录 rm命令刪除一个目录中的一个或多个文件或目录，其中需要注意的参数有： -f 不需要确认删除多个文件，强制删除 -r 将文件的全部目录和子目录都删除 cat命令可以显示文件内容，也可以连接两个或者多个文件 which命令显示文件的所在路径 man命令用于查看Linux中的命令帮助信息，遇到不会的命令就man一下，它也有一些参数需要注意： -a 在所有的man帮助手册中搜索； -f 等价于whatis指令，显示给定关键字的简短描述信息； ps命令ps命令列出执行这个命令时刻时的那些进程，类似一个当前进程的快照，是最基本也是最强大的进程查看命令，需要注意的参数有： a 显示所有进程 -a 显示同一终端下的所有程序 -A 显示所有进程 c 显示进程的真实名称 e 显示环境变量 f 显示程序间的关系 -H 显示树状结构 -au 显示较为详细的信息 tar命令很常用的压缩&amp;&amp;解压命令了，但tar这个命令….参数是真的多，看到一种不错的记忆方法，只要记得参数是【必选+自选+f】即可，首先是必选参数，五选一： -c 意为 create，表示创建压缩包 -x 意为 extract，表示解压 -t 表示查看内容 -r 给压缩包追加文件 -u 意为 update，更新压缩包中的文件 然后是自选参数，必选的话只能选一个，而可以根据需要挑着选： -z 使用 gzip 属性 -j 使用 bz2 属性 -Z 使用 compress 属性 -v 意为 verbose，显示详细的操作过程 -O 将文件输出到标准输出 最后一个参数一定要是f，后面再跟上你要压缩或者解压的文件包名。 一般我们常用的解压方式就是： *.tar -&gt; tar -xf *.tar.gz -&gt; tar -xzf *.tar.bz2 -&gt; tar -xjf *.tar.Z -&gt; tar -xZf *.gz -&gt; gzip -d *.rar -&gt; `unrar e *.zip -&gt; unzip kill命令用于终止指定进程的运行，对于后台进程我们可以先通过ps/pidof/pstree/top等命令获取进程PID，然后用kill结束该进程。不过也可以使用killall命令，直接使用进程的名称结束进程，使用它可以结束一组同名进程，而不用先获取进程PID，killall相当于把这两个过程合二为一，是一个很好用的命令 head命令可以用来查看一个文件的前几行，可以配合其他命令使用，例如配合管道做grep tail命令tail命令和head相反，查看文件的最后几行。不过最常用的还是加上 “-f” 参数后和grep一起使用 grep命令一个极其强大的命令，常用来在很多数据中找到匹配某一模式的字段，可以是正则表达式，常用的几个参数有： -a 以文本文件方式搜索 -c 计算找到的符合行的次数 -i 忽略大小写 -n 顺便输出行号 -v 反向选择，查找没有搜索字符串的行 du命令du命令是对文件和目录磁盘使用空间的查看 top命令用于动态的显示进程的信息，不过也有可以自定义的形式，例如:top -u root可以用来查看某用户进程 find命令查找所需文件的命令，如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件，常用的参数有： -type 只寻找符合指定的文件类型的文件,其后跟随指定文件类型参数，类型参数有 f 普通文件 l 符号连接 d 目录 c 字符设备 b 块设备 s 套接字 p FIFO -name 根据文件名查找 -size 根据文件的权限或者大小名字类型进行查找 -mtime 查找在指定时间曾被更改过的文件或目录，单位以24小时计算； -print 假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出 -exec 假设find指令的回传值为True，就执行其后跟着的指令 cmp命令用来比较两个文件的差异。如果两个文件完全一样，就不会显示任何信息。如果发现有差异，会标示出第一个不同之处的字符和列数编号。 touch命令修改文件的创建日期，或者以当前的系统日期创建一个空文件 date命令显示当前日期和时间的，可以通过一些参数进行日期的格式化： %Y year %m month (01~12) %d day of month %H hour (00~23) %I hour (01~12) %M minute (00~59) %S second (00~60)例如：1234date + &quot;%Y%m%d %H%M%S&quot;20180519 223856date + &quot;%Y-%m-%d %H:%M:%S&quot;2018-05-19 22:39:07 wc命令统计指定文件中的字节数、字数、行数，并将统计结果输出，需要了解的参数有： -c 统计字节数 -l 统计行数 -m 统计字符数，不能与-c参数一起使用 -w 统计字数 env/export命令env: 查看当前环境变量 类似于配置Python环境，在一台不熟悉的机器上，如果出现了配置问题，可以通过env命令查看shell下的所有环境配置，看一下路径是否正确。 export: 设置或显示环境变量 useradd命令useradd命令用于创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。其中有几个需要注意的参数： -e 指定帐号的有效期限 -g 指定用户所属的群组 -G 指定用户所属的附加群组 -r 建立系统帐号 -u 指定用户id，设定ID值时尽量要大于500，以免冲突 groupadd命令用于创建一个新的工作组，也可以用groupdel命令删除工作组，常用的参数有： -g 指定新建工作组的id -r 创建系统工作组，系统工作组的组ID小于500 curl/wget命令curl命令是一个利用URL规则在命令行下工作的文件传输工具,而wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。 netstat命令用来显示网络系统的状态信息，可让你了解整个系统的网络情况，需要注意的参数有： -a 显示所有连线中的Socket -n 直接使用ip地址，而不通过域名服务器 -t 显示TCP传输协议的连线状况 -u 显示UDP传输协议的连线状况 -l 显示监控中的服务器的Socket -s 显示网络工作信息统计表 -n 直接使用ip地址，而不通过域名服务器 可以通过参数的组合实现不同的功能，例如 1234567netstat -at #列出所有tcp端口netstat -au #列出所有udp端口netstat -lt #只列出所有监听 tcp 端口netstat -lu #只列出所有监听 udp 端口netstat -st #显示TCP端口的统计信息netstat -su #显示UDP端口的统计信息netstat -an | grep &#x27;:80&#x27; #找出运行在指定端口的进程","categories":[{"name":"Technology","slug":"Technology","permalink":"https://www.shengshiyu.com/categories/Technology/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.shengshiyu.com/tags/Linux/"}]},{"title":"Git小记","slug":"Git小记","date":"2020-03-16T22:43:00.000Z","updated":"2021-09-27T08:51:02.510Z","comments":true,"path":"2020/03/16/Git小记/","link":"","permalink":"https://www.shengshiyu.com/2020/03/16/Git%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"常用命令设置和配置 git config12345678git config --global user.name &quot;xxx&quot; # 配置用户名git config --global user.email &quot;xxx@xxx.com&quot; # 配置邮件git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy # remove proxy configuration on git 创建和获取项目 git init初始化本地git仓库（创建新仓库） git cloneclone远程仓库 快照 git add应该理解为“添加内容到下一次提交中更合适” 12git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至index git commit 123git commit -m &#x27;xxx&#x27; # 提交并键入提交信息git commit --amend -m &#x27;xxx&#x27; # 重新尝试提交，合并上一次的提交，用于反复修改git commit -am &#x27;xxx&#x27; # 将add和commit合为一步 git diffgit diff本身并不会显示出自上一次提交以来所有的变更，而只会显示出还没有进入暂存区的那些变更，如果所有变更已经进入暂存区，git diff不会有任何输出。 1234567git diff # 显示所有未添加至index的变更git diff --cached # 显示所有已添加index但还未commit的变更git diff --staged # 将暂存的变更与上一次提交相比较git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容 git rm 12git rm xxx # 删除index中的文件git rm -r * # 递归删除 git mv 1git mv README README2 # 重命名文件README为README2 git status用来查看当前文件状态，查看是否进行了修改 1git status -s # 更为紧凑的形式查看变更 分支与合并 git log 123456git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log --stat # 查看每个提交的简要统计信息git log -p -2 # 显示出最近两次提交所引入的差异git log v1.0 # 显示v1.0的日志git log --pretty=format:&#x27;%h %s&#x27; --graph # 更改日志输出默认格式，其结果不会随着Git软件版本更新而改变 git tag 12git tag # 显示已存在的taggit tag -a v1.0 -m &#x27;xxx&#x27; # 增加v1.0的tag git branch列出你所拥有的分支、创建的新分支、删除分支以及重命名分支 123456789git branch # 显示本地分支git branch --contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933 git checkout切换分支并将内容检出到工作目录 1234567git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v1.0 # 检出版本v1.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout -- README # 检出head版本的README文件（可用于修改错误回退） git merge用于将一个或多个分支合并，然后将合并的分支作为当前分支 1git merge origin/master # 合并远程master分支至当前分支 git stash 123git stash list # 查看所有暂存git stash show -p stash@&#123;0&#125; # 参考第一次暂存git stash apply stash@&#123;0&#125; # 应用第一次暂存 项目共享和更新 git remote用来查看已经设置了哪些远程仓库，然后列出每个远程仓库的简短名称，也可以用来管理远程仓库记录，将一段很冗杂的URL地址保存成一个简单的字符串句柄，比如origin，方便操作 1git remote add &lt;name&gt; &lt;url&gt; # 增加远程定义（用于push/pull/fetch） git push与其他仓库通信，确定本地内容和远程仓库异同，然后将差异推送到其他仓库 123git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push --tags # 把所有服务器上还没有的标记都推送过去 git fetch 123git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支git fetch origin # 与服务器同步 git pull可以理解为git fetch和git merge的组合，先从远程仓库获取内容，再尝试合并进你所在分支 1git pull origin master # 获取远程分支master并merge到当前分支 git reset 1git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退） 检视和比较 git show能够以简单易读的形式显示Git对象，通常用来显示标签或提交的相关信息 12345678git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git show v1.0 # 显示v1.0的日志及详细内容git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125; # 显示master分支昨天的状态git show HEAD~3git show -s --pretty=raw 2be7fcb476 git ls-files 1git ls-files # 列出git index包含的文件 git show-branch 12git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史 调试 git grep可以帮助你在源代码的所有文件中找到任意字符串12git grep &quot;delete from&quot; # 文件中搜索文本“delete from”git grep -e &#x27;#define&#x27; --and -e SORT_DIRENT 打补丁 git cherry-pick 1git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改 git rebase基本上就是一个自动化的git cherry-pick命令，它确定一系列提交，然后在别处以相同的顺序逐个对其挑拣。不要对已经存在于本地仓库之外的提交执行rebase操作。 git revert与git cherry-pick命令的效果恰好相反，将变更撤销或还原 1git revert dfb02e6e4f2f7b # 撤销提交dfb02e6e4f2f7b 管理 git reflog显示所有提交，包括孤立节点 git gc执行”垃圾回收“，删除无用文件，将余下的文件打包成一种更有效的形式 git fsck用于检查内部数据库存在的问题或不一致性 Git使用规范流程 在团队开发中，遵循一个合理、清晰的规范是很重要的，例如Git,如果每个人都很随意的提交一堆commit，项目很快就会变得难以维护和管理了，所以需要规范化这个流程。 一、新建分支每次开发一个新的功能，我们都应该新建一个单独的分支 123456# 获取最新代码git checkout mastergit pull# 新建一个开发分支git checkout mybranch 二、提交分支分支修改后，就可以提交了 123git add .git statusgit commit 三、撰写提交信息提交commit时，必须要简洁明了的叙述提交的信息，可以参考这个例子： 123456简要的变更汇总，然后空一行（不超过50个字符），如果有必要，就要附加更详细的说明，每行长度限制在72个字符左右。- 通常使用连字符或者星号作为条目符号- 改动原因- 主要变动- 需要注意的问题 四、与主分支同步开发的过程中要时常与主分支保持同步 12git fetch origingit rebase origin/master 五、合并开发完成后，我们需要把一堆commit合并到主分支关于合并多个commit,可以看这篇文章：「Git」合并多个 Commit不过也有一种简洁的合并方式,就是先撤销过去5个commit，然后再建一个新的： 1234git reset HEAD~5git add .git commit -am &quot;Here&#x27;s the bug fix that closes #28&quot;git push --force 六、推送远程仓库1git push --force origin myfeature 之所以要加上 force 参数，是因为 rebase 后，分支历史改变引起的远程分支不兼容问题 七、发出Pull Request提交完毕后，就可以发出 Pull Request 到 master 分支，然后请求别人进行代码 review ，确认是否可以合并到 master 分支。 Git工作流主流工作流 Git Flow GitHub Flow GitLab Flow Git FlowGit Flow 是最早诞生、并得到广泛采用的一种工作流程。 Git Flow 存在两个长期分支，分别是主分支 master 和开发分支 develop ，前者是对外发布的稳定版本，后者相当于测试开发版，用于日常开发使用。 Git Flow还有三个协助分支，分别是功能分支（分模块功能开发）、补丁分支（线上的紧急 bug 修复）、和预发分支（版本发布的预发布），分别对应不同的业务需求，一旦开发完成，它们会先合并进开发分支，再合并进主分支，或者直接并入主分支。 Git Flow的优点在于直观明了，易于控制，但需要维护两个长期分支，需要频繁切换，而且这个模式更多基于“版本发布”的，对于一些“持续发布”的项目，两个长期分支的区别就不大，没必要都维护。 GitHub FlowGitHub Flow 作为 Github 所使用的工作流，其目的也是专门为了配合“持续发布”的。它只有一个长期分支，就是我们所熟知的 master 分支，团队成员们的分支代码通过 Pull Request 来合并到 master 上。 我们通过从 mater 上拉出新的分支，当开发完成时，就发起一个Pull Request，然后会审核你的代码，如果被接受就可以合并进 master 分支。 不过由于它只有一个主分支，所以如果你的开发时间很长，主分支就会与你得分支版本不一致，而你不得不专门建一个分支跟踪线上的新版本。 GitLab FlowGitlab flow 吸取了 Git flow 与 Github flow 的优点。既有适应不同开发环境的弹性，又有单一主分支的简单和便利。 对于”持续发布”的项目，建议在 master 分支以外，再建立不同的环境分支。比如，”开发环境”的分支是 master ，”预发环境”的分支是 pre-production ，”生产环境”的分支是 production 。 开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。只有上游没有问题，才能发布到下游，除非是紧急情况，才能直接合并到下游分支。 对于”版本发布”的项目，都要从 master 分支拉出一个分支，比如1-3-stable、1-4-stable等等。发现问题，就从对应版本分支创建修复分支，完成之后，先合并到 master，才能再合并到 release 分支，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。 Git代码规范 具体可以看一下这篇文章：[Git Style Guide](https://github.com/agis/git-style-guide)","categories":[{"name":"Technology","slug":"Technology","permalink":"https://www.shengshiyu.com/categories/Technology/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.shengshiyu.com/tags/Git/"}]},{"title":"Markdown小记","slug":"Markdown小记","date":"2020-01-05T22:24:38.000Z","updated":"2021-09-27T08:51:02.510Z","comments":true,"path":"2020/01/05/Markdown小记/","link":"","permalink":"https://www.shengshiyu.com/2020/01/05/Markdown%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"标题 如果你需要插入标题，可以在行首插入1到6个#，对应标题的1到6级,最高可以到六级标题，最好在#后加一个空格，例如:# 这是一级标题## 这是二级标题####### 这是六级标题 也可以使用=====表示高级标题，使用------表示次级标题，大于两个=,-都可以用来表示标题 引用如果你需要一个引用，那么你可以使用&gt;符号放在文字开头，例如:&gt;这是一个引用引用是可以嵌套的，同时引用的区块内部也可以使用其他的Markdown语法，例如 这是一个引用 这是一个嵌套引用 这是二级标题 列表项 列表项 列表如果你需要一个列表，在Markdown里，你可以选择有序列表和无序列表两种形式，列表本身也是可以嵌套，例如 列表项 列表项 列表项 嵌套列表 嵌套列表 无序列表可以使用*、+、-这三个符号中的任意一种作为列表标记，也可以和引用标记进行嵌套 列表项 列表项 列表项 这是一个嵌套的引用 可以进一步嵌套 字体 粗体: 通常用**或者__表示粗体 斜体: 通常用*或者_表示斜体 斜粗体：通常用***或者___表示斜粗体 链接如果你需要链接文字，可以使用[](link)表示一个链接，其中[]内是需要添加链接的文字，()内是链接的地址 代码 使用一对```表示代码块，可以根据你所使用的Markdown编辑器,选择在第一个```后添加代码的language，产生高亮效果，例如：123public static void main(String[] args) &#123; System.out.println(&quot;Hello&quot;); &#125; 使用一对 可以表示一个行内代码，例如： 这是一个Java`代码 图片如果你需要插入一张图片，可以使用![Text](path)，其中Text表示图片无法加载时显示的文字，path为图片所在的路径，也可以是网上的图片链接地址 分割线如果你需要一条分割线，可以使用--- 或者***表示水平分割线，只要-,*大于三个就可以表示水平分割线，使用---作分割线时需要前后都空一行，防止被当成标题的标记方式 删除线如果你需要一条删除线,可以使用一对~~表示删除线，但切记和文字之间不能有空格 表格可以使用以下的格式添加表格,注意表格和文字间空一行： 12345| name | age | gender | money ||-------|:---:|-----------|-------:|| rhio | 384 | robot | $3,000 || haroo | .3 | bird | $430 || jedi | ? | undefined | $0 | name age gender money rhio 384 robot $3,000 haroo .3 bird $430 jedi ? undefined $0 其他如果 Markdwon 的语法达不到预期效果，或者一些地方的处理用 Markdwon 的格式无法实现，可以考虑用 HTML 和 CSS 引用123&lt;blockquote&gt;***&lt;/blockquote&gt;/* 如果上下间距小，可以这样写 */&lt;p&gt;&lt;blockquote&gt;***&lt;/blockquote&gt;&lt;/p&gt; 居中和右对齐123456/* 居中 */&lt;center&gt;**&lt;/center&gt;/* 右对齐 */&lt;p style=&quot;text-align:right&quot;&gt;**&lt;/p&gt;/* 右对齐 */&lt;p style=&quot;text-align:left&quot;&gt;**&lt;/p&gt; 字体大小和颜色1&lt;font color=&quot;#xxxxxx&quot; size=&quot;number&quot;&gt;**&lt;/font&gt; 分割线和空行12&lt;hr /&gt;&lt;br /&gt; 关于Markdown的更多细节，可以参看：[Markdown 语法说明 (简体中文版)](https://www.appinn.com/markdown/)，对于Markdown的规范，可以看一下 ：[Google Markdown Style Guide](https://github.com/google/styleguide/blob/gh-pages/docguide/style.md) 或者 [Markdown Style Guide](http://www.cirosantilli.com/markdown-style-guide/)","categories":[{"name":"Technology","slug":"Technology","permalink":"https://www.shengshiyu.com/categories/Technology/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.shengshiyu.com/tags/Markdown/"}]}],"categories":[{"name":"Technology","slug":"Technology","permalink":"https://www.shengshiyu.com/categories/Technology/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.shengshiyu.com/tags/Vue/"},{"name":"Electron","slug":"Electron","permalink":"https://www.shengshiyu.com/tags/Electron/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengshiyu.com/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.shengshiyu.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Linux","slug":"Linux","permalink":"https://www.shengshiyu.com/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"https://www.shengshiyu.com/tags/Git/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.shengshiyu.com/tags/Markdown/"}]}